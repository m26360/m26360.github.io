<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git Bash的基本命令</title>
    <url>/2021/07/31/Git%20Bash%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="第-1-个命令："><a href="#第-1-个命令：" class="headerlink" title="第 1 个命令："></a>第 1 个命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<p>在命令行窗口的光标处，输入git status命令，查看仓库的状态<br>注：在每个git操作之后，我们基本都会输入git status命令，查看仓库状态。这也从侧面说明了git status命令使用的频率之高，也建议大家在操作 Git 仓库的时候多使用git status命令，这能帮助我们实时了解仓库的状态，显然非常有用。</p>
<h3 id="第-2-个命令："><a href="#第-2-个命令：" class="headerlink" title="第 2 个命令："></a>第 2 个命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>在命令行窗口的光标处，输入git init命令，初始化 Git 仓库</p>
<h3 id="第-3-个命令："><a href="#第-3-个命令：" class="headerlink" title="第 3 个命令："></a>第 3 个命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add</span><br></pre></td></tr></table></figure>
<p>在命令行窗口的光标处，输入git add hit.txt命令，将hit.txt文件添加到 Git 仓库<br>注：git add命令并没有把文件提交到 Git 仓库，而是把文件添加到了「临时缓冲区」，这个命令有效防止了我们错误提交的可能性。</p>
<span id="more"></span>

<h3 id="第-4-个命令："><a href="#第-4-个命令：" class="headerlink" title="第 4 个命令："></a>第 4 个命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure>
<p>在命令行窗口的光标处，输入git commit -m “text commit”命令，将hit.txt文件提交到 Git 仓库<br>其中commit表示提交，-m表示提交信息，提交信息写在双引号””内。</p>
<h3 id="第-5-个命令："><a href="#第-5-个命令：" class="headerlink" title="第 5 个命令："></a>第 5 个命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<p>在命令行窗口的光标处，输入git log”命令，打印 Git 仓库提交日志<br>注：提交记录的内容包括Author提交作者、Date提交日期和提交信息。</p>
<h3 id="第-6-个命令："><a href="#第-6-个命令：" class="headerlink" title="第 6 个命令："></a>第 6 个命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
<p>在命令行窗口的光标处，输入git branch命令，查看 Git 仓库的分支情况<br>注：*号表示“当前所在的分支”，或者看后边蓝色小括号即为当前所在分支。</p>
<h3 id="第-7-个命令："><a href="#第-7-个命令：" class="headerlink" title="第 7 个命令："></a>第 7 个命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout</span><br></pre></td></tr></table></figure>
<p>在命令行窗口的光标处，输入git checkout a命令，切换到a分支</p>
<h3 id="第-8-个命令："><a href="#第-8-个命令：" class="headerlink" title="第 8 个命令："></a>第 8 个命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge</span><br></pre></td></tr></table></figure>
<p>切换到master分支，然后输入git merge a命令，将a分支合并到master分支<br>注：在合并分支的时候，要考虑到两个分支是否有冲突，如果有冲突，则不能直接合并，需要先解决冲突；反之，则可以直接合并。</p>
<h3 id="第-9-个命令："><a href="#第-9-个命令：" class="headerlink" title="第 9 个命令："></a>第 9 个命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d &amp; git branch -D</span><br></pre></td></tr></table></figure>
<p>在命令行窗口的光标处，输入git branch -d a命令，删除a分支<br>注：有的时候，通过git branch -d命令可以出现删除不了现象，例如分支a的代码没有合并到主分支等，这时如果我们一定要删除该分支，那么我们可以通过命令git branch -D进行强制删除。</p>
<h3 id="第-10-个命令："><a href="#第-10-个命令：" class="headerlink" title="第 10 个命令："></a>第 10 个命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure>
<p>在命令行窗口的光标处，输入git tag v1.0命令，为当前分支添加标签，通过命令git tag即可查看标签记录，通过命令git checkout v1.0即可切换到该标签下的代码状态</p>
<p><font color="#dd0000">（注：在我们进行任何的git操作之前，我们都得先切换到 Git 的仓库目录。换言之，我们得到先进入到（我们定义的）Git 仓库的最顶层文件目录下，然后从此目录中进入 Git Bash，这样之后的操作才能顺利进行。如果是 Linux 操作系统，则可以直接cd到仓库目录。）</font><br /></p>
<p>注：原作者：GitHubPorn<br>链接：<a href="https://zhuanlan.zhihu.com/p/369486197">https://zhuanlan.zhihu.com/p/369486197</a><br>（博主在此基础上进行精简，摘取，修改）</p>
]]></content>
      <categories>
        <category>Git使用相关</category>
      </categories>
  </entry>
  <entry>
    <title>使用ubuntu，目录为中文的解决办法</title>
    <url>/2021/07/29/%E4%BD%BF%E7%94%A8ubuntu%EF%BC%8C%E7%9B%AE%E5%BD%95%E4%B8%BA%E4%B8%AD%E6%96%87%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>终端输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LANG=en_US</span><br></pre></td></tr></table></figure>
<p>并执行</p>
<p>终端输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xdg-user-dirs-gtk-update</span><br></pre></td></tr></table></figure>
<p>并执行，</p>
<p>弹出窗口，选择不再提示，并确认</p>
<p>终端输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LANG=zh_CN</span><br></pre></td></tr></table></figure>
<p>并执行</p>
<p>关闭终端并重启ubuntu</p>
]]></content>
      <categories>
        <category>杂项汇总</category>
      </categories>
  </entry>
  <entry>
    <title>hexo如何新建文章</title>
    <url>/2021/08/15/hexo%E5%A6%82%E4%BD%95%E6%96%B0%E5%BB%BA%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h3 id="1-新建文章"><a href="#1-新建文章" class="headerlink" title="1.新建文章"></a>1.新建文章</h3><h4 id="（1）输入命令"><a href="#（1）输入命令" class="headerlink" title="（1）输入命令"></a>（1）输入命令</h4><p>在hexo博客目录下，右键选择Git Bash Here,输入以下代码并回车：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;文章名字&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="（2）文章所在位置"><a href="#（2）文章所在位置" class="headerlink" title="（2）文章所在位置"></a>（2）文章所在位置</h4><p>在hexo博客目录下的/source/_posts/文件夹里，可以找到你新建的博客文件.md，直接打开编辑文章即可（使用Markdown语法）。传送门：<a href="https://www.appinn.com/markdown/">Markdown语法教程</a></p>
<h3 id="2-编辑文章"><a href="#2-编辑文章" class="headerlink" title="2.编辑文章"></a>2.编辑文章</h3><h4 id="（1）设置文章所属tags（标签）和categories（分类）"><a href="#（1）设置文章所属tags（标签）和categories（分类）" class="headerlink" title="（1）设置文章所属tags（标签）和categories（分类）"></a>（1）设置文章所属tags（标签）和categories（分类）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: hexo如何新建文章</span><br><span class="line">date: 2021-08-15 11:55:43</span><br><span class="line">tags: （设置标签的地方）</span><br><span class="line">categories: （设置分类的地方）</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p><font color="#dd0000">（注：设置属性的冒号后面要有一个空格，一定要注意！）</font><br /></p>
<h4 id="（2）设置阅读全文按钮"><a href="#（2）设置阅读全文按钮" class="headerlink" title="（2）设置阅读全文按钮"></a>（2）设置阅读全文按钮</h4><p>在文章中使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>
<p>之后的代码将不会被显示。</p>
<h3 id="3-将文章部署到Github"><a href="#3-将文章部署到Github" class="headerlink" title="3.将文章部署到Github"></a>3.将文章部署到Github</h3><p>（1）在Git中依次执行以下3行代码（3部曲）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo c</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>（每次执行3部曲的时候，都要进入Github仓库重新设置一下Page为你的域名，至于问什么会出现这种问题，我也不知道）</p>
<p>接下来访问自己的博客域名，就能看到新的文章了！</p>
]]></content>
      <categories>
        <category>hexo博客操作相关</category>
      </categories>
  </entry>
  <entry>
    <title>hexo 双线部署到Coding和GitHub</title>
    <url>/2021/08/16/hexo-%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2%E5%88%B0Coding%E5%92%8CGitHub/</url>
    <content><![CDATA[<p>因为教程步骤繁琐，具体请参考:<a href="https://cloud.tencent.com/developer/article/1834005">https://cloud.tencent.com/developer/article/1834005</a></p>
]]></content>
  </entry>
  <entry>
    <title>数据结构之稀疏数组</title>
    <url>/2021/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>当一个数组中大部分元素为0，或者为同一个值，可以使用稀疏数组来保存该数组。</p>
<h4 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h4><p>1.记录数组一共有几行几列，有多少个不同的值。<br>2.把具有不同的元素的行列及值记录在一个小规模数组中（稀疏数组），从而缩小程序规模。</p>
<span id="more"></span>

<h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p>原始二维数组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">0  0  0  1  0              </span><br><span class="line">0  1  0  0  2</span><br><span class="line">0  0  3  0  0         </span><br><span class="line">0  0  3  0  0</span><br><span class="line">2  0  5  0  0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>转换为：<br>        稀疏数组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">     行  列   值</span><br><span class="line">    row  col  val</span><br><span class="line">[0]  4    5    6 总（原始二维数组有几行几列，几个不同值） </span><br><span class="line">[1]  0    3    1</span><br><span class="line">[2]  1    1    1</span><br><span class="line">[3]  1    4    2</span><br><span class="line">[4]  2    2    3</span><br><span class="line">[5]  3    0    2</span><br><span class="line">[6]  3    2    5</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>行数不确定，列数始终为3</p>
<h4 id="二维数组转稀疏数组思路"><a href="#二维数组转稀疏数组思路" class="headerlink" title="二维数组转稀疏数组思路"></a>二维数组转稀疏数组思路</h4><p>1.遍历原始二维数组，得到有效数据个数(sum)。<br>2.根据sum的值创建稀疏数组int[][] sparseArr=new int[sum+1][3];<br>3.将二维数组有效数据存入到稀疏数组中。（[0]行为总数）</p>
<h4 id="稀疏数组转二维数组思路"><a href="#稀疏数组转二维数组思路" class="headerlink" title="稀疏数组转二维数组思路"></a>稀疏数组转二维数组思路</h4><p>1.先读取稀疏数组第一行，根据第一行数据，创建原始二维数组(chessArr2)。<br>2.再读取稀疏数组后几行的数据，并赋值给原始的二维数组(chessArr2)。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.sparsearray;</span><br><span class="line"></span><br><span class="line">public class SparseArray &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //创建原始二维数组11*11（棋盘大小）</span><br><span class="line">        //0表示没有棋子，1表示黑子，2表示蓝子</span><br><span class="line">        int[][] chessArr1 = new int[11][11];</span><br><span class="line">        chessArr1[1][2] = 1;</span><br><span class="line">        chessArr1[2][3] = 2;</span><br><span class="line"></span><br><span class="line">        //输出原始二维数组</span><br><span class="line">        System.out.println(<span class="string">&quot;原始数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (int[] row : chessArr1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (int data : row) &#123;</span><br><span class="line">                System.out.print(data + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //将二维数组转成稀疏数组</span><br><span class="line">        //遍历二维数组，得到非0元素的个数</span><br><span class="line">        int sum = 0;</span><br><span class="line">        <span class="keyword">for</span> (int[] row : chessArr1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (int data : row) &#123;</span><br><span class="line">                <span class="keyword">if</span> (data != 0) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //定义一个稀疏数组</span><br><span class="line">        int[][] sparseArr = new int[sum + 1][3];</span><br><span class="line">        sparseArr[0][0] = 11;</span><br><span class="line">        sparseArr[0][1] = 11;</span><br><span class="line">        sparseArr[0][2] = sum;</span><br><span class="line"></span><br><span class="line">        //普通<span class="keyword">for</span>循环遍历二维数组，得到下标，用于储存到稀疏数组中</span><br><span class="line">        int count = 0;    //用于记录第几个非0数据以及对应的稀疏数组的行索引</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; chessArr1.length; i++)</span><br><span class="line">            <span class="keyword">for</span> (int j = 0; j &lt; chessArr1.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr1[i][j] != 0) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArr[count][0] = i;</span><br><span class="line">                    sparseArr[count][1] = j;</span><br><span class="line">                    sparseArr[count][2] = chessArr1[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        //遍历输出稀疏数组</span><br><span class="line">        System.out.println(<span class="string">&quot;稀疏数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (int[] row : sparseArr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (int data : row) &#123;</span><br><span class="line">                System.out.print(data + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //稀疏数组还原为二维数组</span><br><span class="line">        //读取稀疏数组第一行，创建二维数组</span><br><span class="line">        int [][]chessArr2=new int[sparseArr[0][0]][sparseArr[0][1]];</span><br><span class="line"></span><br><span class="line">        //读取稀疏数组的后几行（第二行开始），并赋值给二维数组</span><br><span class="line">        <span class="keyword">for</span> (int i=1;i&lt;sparseArr.length;i++) &#123;</span><br><span class="line">            chessArr2[sparseArr[i][0]][sparseArr[i][1]]=sparseArr[i][2];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //输出chessArr2数组</span><br><span class="line">        System.out.println(<span class="string">&quot;恢复后chessArr数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (int[] row : chessArr2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (int data : row) &#123;</span><br><span class="line">                System.out.print(data + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><font color="#dd0000">（注：二维数组增强for循环遍历第一次得到的是类型为int[]的行，类型为int[]的行再次增强for循环得到二维数组的每一个值。）</font><br /></p>
<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>以上内容为博主总结，用于日后复习与巩固，如果转载请注明来源，谢谢。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>关于昨天尝试双线部署hexo</title>
    <url>/2021/08/17/%E5%85%B3%E4%BA%8E%E6%98%A8%E5%A4%A9%E5%B0%9D%E8%AF%95%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2hexo/</url>
    <content><![CDATA[<p>因为此博客是部署在Github上的，所以国内访问会比较慢，甚至无法访问，正好看到了将hexo双线部署在Github和Coding上，顺便也能让百度收录此博客，于是就尝试了一下，coding账号注册，新建项目，新建仓库，修改博客config文件，修改DNS解析，配置密匙，将Github解析改为境外访问等等…一气呵成，最后发现博客无法打开，因为网上的教程都是腾讯云开发平台的教程，好像是coding被腾讯收购了，而我用的又是coding，难免会有些设置不存在或者找不到，导致最终失败了，昨天也是弄了几个小时，头晕眼花，等过一段时间我再重新试一下。</p>
]]></content>
      <categories>
        <category>记录心情</category>
      </categories>
  </entry>
  <entry>
    <title>学习进度</title>
    <url>/2021/08/22/%E5%AD%A6%E4%B9%A0%E8%BF%9B%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h3><h4 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h4><p>1.将hexo博客进行了双线部署。<br>2.将博客提交到百度收录。</p>
<h4 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h4><p>1.学习队列<br>2.学习环形队列</p>
]]></content>
      <categories>
        <category>学习进度及目标</category>
      </categories>
  </entry>
  <entry>
    <title>第一次拥有了属于自己的博客</title>
    <url>/2021/07/29/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8B%A5%E6%9C%89%E4%BA%86%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>欢迎来到mana的小窝，这是我的第一个博客！很久以前就想建立一个自己的博客，当时因为各种原因未能实现（主要还是技术菜），昨天突然心血来潮，再次想要创建博客，于是在网络上看到一篇文章：用<a href="https://zhuanlan.zhihu.com/p/102592286">Github+hexo</a>创建博客，说到Github，很久以前注册过账号，但也仅仅是停留在注册这里,并没有真正用过，我想，以后应该会经常使用的。所以就照着答主的教程开始搭建，期间因为种种原因，遇到很多问题，各种百度查资料，最终还是完成了。过后我会在他的基础上完善修正一下搭建博客的教程。</p>
<h2 id="创建此博客的想法"><a href="#创建此博客的想法" class="headerlink" title="创建此博客的想法"></a>创建此博客的想法</h2><p>因为本人是软件工程专业的，写下此篇博客的时间为大一下的暑假。因为在此之前自学完了javase，html、css、javascript的基础语法，当时也没有将遇到的问题记录下来，也是有点小遗憾。所以博客仅用来分享记录我学习路上遇到的问题和心情等等。</p>
]]></content>
      <categories>
        <category>记录心情</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之队列(1)</title>
    <url>/2021/09/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97(1)/</url>
    <content><![CDATA[<h3 id="队列（数组模拟实现）"><a href="#队列（数组模拟实现）" class="headerlink" title="队列（数组模拟实现）"></a>队列（数组模拟实现）</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1.队列是个有序列表，可以用数组或链表来实现<br>2.遵循先入先出原则，即先存入队列的数据先取出，后存入队列的数据后取出</p>
<span id="more"></span>

<h4 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h4><p>1.队列的输出、输入分别从前后端来处理，需要两个变量front和rear分别记录队列前后端的索引，front会随着数据的输出而改变，rear会随着数据的输入而改变。还需要一个变量maxSize来记录队列的最大容量。<br><font color="#dd0000"><br>front = -1，进行初始化，指向队列头的前一个位置<br>rear = -1， 指向队列尾部的数据（就是队列最后一个数据）<br></font><br /></p>
<h4 id="队列数据的添加操作"><a href="#队列数据的添加操作" class="headerlink" title="队列数据的添加操作"></a>队列数据的添加操作</h4><p>1.将数据存入队列时称为“addQueue”，“addQueue”的处理需要两个步骤：<br>1)先判断队列是否为满，若尾指针rear小于队列的最大索引maxsize-1，则将数据存入rear所指的数组元素中，否则无法存入数据。<font color="#dd0000">（rear==maxSize-1时，队列满，即无法添加数据）</font><br /><br>2)将尾指针(rear)往后移：rear+1，将要添加的数赋值给索引为rear+1的数组。<font color="#dd0000">（注：当front==rear时，队列为空）</font><br /></p>
<h4 id="队列数据的取出操作"><a href="#队列数据的取出操作" class="headerlink" title="队列数据的取出操作"></a>队列数据的取出操作</h4><p>1.从队列中取出数据时称为“getQueue”，“getQueue”的处理需要两个步骤：<br>1)判断队列是否为空。<br>2)将front往后移，取出的数为索引为rear+1的元素。</p>
<h4 id="已知问题及优化"><a href="#已知问题及优化" class="headerlink" title="已知问题及优化"></a>已知问题及优化</h4><p>1.问题：数组使用一次就不能用了，没有达到复用的效果。<br>2.优化：将这个数组使用算法，改进成一个环形的队列。（取模:%）<font color="#dd0000">（见数据结构之队列(2)）</font><br /></p>
<h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.queue;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class ArrayQueueDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建队列</span><br><span class="line">        ArrayQueue arrayQueue = new ArrayQueue(3);</span><br><span class="line">        //接收用户输入</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        boolean loop = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s(show)：显示队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(exit)：退出队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a(add)：添加数据到队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g(get)：从队列取出数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(head)：查看队列头的数据&quot;</span>);</span><br><span class="line">            char key = sc.next().charAt(0);</span><br><span class="line">            switch (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    arrayQueue.showQueue();</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                    sc.close();</span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    System.out.println(<span class="string">&quot;程序退出&quot;</span>);</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入一个数：&quot;</span>);</span><br><span class="line">                    Scanner sc1 = new Scanner(System.in);</span><br><span class="line">                    int value1 = sc.nextInt();</span><br><span class="line">                    arrayQueue.addQueue(value1);</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res = arrayQueue.getQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;取出的数据是%d\n&quot;</span>, res);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res = arrayQueue.headQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;队列头数据是%d\n&quot;</span>, res);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//编写一个ArrayQueue的类</span><br><span class="line">class ArrayQueue &#123;</span><br><span class="line">    private int maxSize;    //表示数组最大容量</span><br><span class="line">    private int front;  //队列头</span><br><span class="line">    private int rear;   //队列尾</span><br><span class="line">    private int[] arr;  //该数组用于存放数据，模拟队列</span><br><span class="line"></span><br><span class="line">    //创建队列的构造器</span><br><span class="line">    public ArrayQueue(int arrMaxSize) &#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = new int[maxSize];</span><br><span class="line">        front = -1;   //进行初始化，指向队列头的前一个位置</span><br><span class="line">        rear = -1;    //指向队列尾部的数据（就是队列最后一个数据）</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断队列是否满</span><br><span class="line">    public boolean <span class="function"><span class="title">isFull</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> maxSize - 1 == rear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断队列是否为空</span><br><span class="line">    public boolean <span class="function"><span class="title">isEmpty</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> front == rear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //添加数据到队列</span><br><span class="line">    public void addQueue(int n) &#123;</span><br><span class="line">        //判断队列是否满</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列满了，无法添加数据！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        //添加数据</span><br><span class="line">        rear++;</span><br><span class="line">        arr[rear] = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取队列的数据（出队列）</span><br><span class="line">    public int <span class="function"><span class="title">getQueue</span></span>() &#123;</span><br><span class="line">        //判断队列是否为空</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            //如果为空，通过抛出异常来处理</span><br><span class="line">            throw new RuntimeException(<span class="string">&quot;队列为空，无法获取数据！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        front++;</span><br><span class="line">        <span class="built_in">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示队列的所有数据</span><br><span class="line">    public void <span class="function"><span class="title">showQueue</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列为空，没有数据！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (int a = 0; a &lt; arr.length; a++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;arr[&quot;</span> + a + <span class="string">&quot;]=&quot;</span> + arr[a] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示队列的头数据（不是取出数据，仅仅是显示）</span><br><span class="line">    public int <span class="function"><span class="title">headQueue</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(<span class="string">&quot;队列为空，没有头数据！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> arr[front + 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>以上内容为博主总结，用于日后复习与巩固，如果转载请注明来源，谢谢。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>解决hexo部署之后需要重新修改域名的问题</title>
    <url>/2021/08/16/%E8%A7%A3%E5%86%B3hexo%E9%83%A8%E7%BD%B2%E4%B9%8B%E5%90%8E%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E4%BF%AE%E6%94%B9%E5%9F%9F%E5%90%8D%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="教程开始"><a href="#教程开始" class="headerlink" title="教程开始"></a>教程开始</h3><p>1.打开博客的source目录，创建CNAME文件，在CNAME中写上自己的域名。<br>2.在hexo博客目录下，右键选择Git Bash Here,输入以下代码并回车：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>3.over!</p>
]]></content>
      <categories>
        <category>hexo博客操作相关</category>
      </categories>
  </entry>
  <entry>
    <title>学习目标</title>
    <url>/2021/09/09/%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87/</url>
    <content><![CDATA[<h3 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h3><h4 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h4><p>1.继续学习数据结构与算法<br>2.复习javase<br>3.学习markdown语法<br>4.给博客添加评论功能<br>5.百度好像还没收录我的博客，不知道哪里出了问题，有时间再弄一下<br>6………</p>
]]></content>
      <categories>
        <category>学习进度及目标</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之队列(2)环形队列</title>
    <url>/2021/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97-2-%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="数组模拟环形队列"><a href="#数组模拟环形队列" class="headerlink" title="数组模拟环形队列"></a>数组模拟环形队列</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p> 用于解决数组模拟队列不能复用的问题。</p>
<span id="more"></span>

<h4 id="思路及图解"><a href="#思路及图解" class="headerlink" title="思路及图解"></a>思路及图解</h4><p>1.front的含义做一个调整：front指向队列的第一个元素。<font color="#dd0000">（原来front指向队列第一个元素的前一个位置）</font><br />也就是说，arr[front]为队列的第一个元素。<font color="#dd0000">（front的初始值为0）</font><br /><br>2.rear的含义也做一个调整：rear指向队列的最后一个元素的后一个位置。<font color="#dd0000">（原来rear指向队列最后一个元素的位置，rear的初始值也为0）</font><br /><br>3.当队列满时，条件为(rear+1)%maxSize==front</p>
<h4 id="图解（很重要！）"><a href="#图解（很重要！）" class="headerlink" title="图解（很重要！）"></a>图解<font color="#dd0000">（很重要！）</font><br /></h4><p><img src="https://i.loli.net/2021/09/19/FBwzUEtshNaLrDA.png" alt="环形队列.png"></p>
<p>(1)数组最大容量为：maxSize=4<br>(2)实际容量为：maxSize-1=3<font color="#dd0000">（因为要预留一个空间作为约定，用于判断队列是否为满，因为如果不留空，那么判断队列空和队列满的条件就都为：rear==front，无法判断）</font><br /><br>(3)第一个元素索引为：front=0<font color="#dd0000">（没有做取出操作的时候）</font><br /><br>(4)索引为3的位置空出来了。<br>(5)当索引为0、1、2的位置都存有元素后，认为该队列为满，此时：<br>1)maxSize=4<br>2)front=0<br>3)rear=3<br>即满足(rear+1)%maxSize==0<font color="#dd0000"> rear、front均代表索引。</font><br /></p>
<p>4.当队列为空时，条件为rear==front<br>5.我们这样分析，队列中有效的数据的个数为：(rear+maxSize-front)%maxSize<br>6.我们就可以在原来的队列上修改得到一个环形队列。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.queue;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class CircleArrayQueueDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建一个环形队列</span><br><span class="line">        CircleArray circleArray = new CircleArray(4);</span><br><span class="line">        //接收用户输入</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        boolean loop = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s(show)：显示队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(exit)：退出队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a(add)：添加数据到队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g(get)：从队列取出数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(head)：查看队列头的数据&quot;</span>);</span><br><span class="line">            char key = sc.next().charAt(0);</span><br><span class="line">            switch (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    circleArray.showQueue();</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                    sc.close();</span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    System.out.println(<span class="string">&quot;程序退出&quot;</span>);</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入一个数：&quot;</span>);</span><br><span class="line">                    Scanner sc1 = new Scanner(System.in);</span><br><span class="line">                    int value1 = sc.nextInt();</span><br><span class="line">                    circleArray.addQueue(value1);</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res = circleArray.getQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;取出的数据是%d\n&quot;</span>, res);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res = circleArray.headQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;队列头数据是%d\n&quot;</span>, res);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CircleArray &#123;</span><br><span class="line">    private int maxSize;    //表示数组最大容量</span><br><span class="line">    private int front;  //队列头 front的含义做一个改变：front指向队列的第一个元素，arr[front]就是队列的第一个元素</span><br><span class="line">    // front的初始值=0</span><br><span class="line">    private int rear;   //队列尾 rear的含义做一个改变：rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为约定</span><br><span class="line">    //rear的初始值=0</span><br><span class="line">    private int[] arr;  //该数组用于存放数据，模拟队列</span><br><span class="line"></span><br><span class="line">    public CircleArray(int arrMaxSize) &#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = new int[maxSize];</span><br><span class="line">        front = 0;</span><br><span class="line">        rear = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断队列是否为满</span><br><span class="line">    public boolean <span class="function"><span class="title">isFull</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> (rear + 1) % maxSize == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断队列是否为空</span><br><span class="line">    public boolean <span class="function"><span class="title">isEmpty</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //添加数据到队列</span><br><span class="line">    public void addQueue(int n) &#123;</span><br><span class="line">        //判断队列是否满</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列满了，无法添加数据！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //添加数据</span><br><span class="line">        arr[rear] = n;</span><br><span class="line">        //将rear后移，这里必须考虑取模%</span><br><span class="line">        rear = (rear + 1) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取队列的数据（出队列）</span><br><span class="line">    public int <span class="function"><span class="title">getQueue</span></span>() &#123;</span><br><span class="line">        //判断队列是否为空</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            //如果为空，通过抛出异常来处理</span><br><span class="line">            throw new RuntimeException(<span class="string">&quot;队列为空，无法获取数据！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        //先用临时变量保存front的值，如果不这么做，会导致<span class="built_in">return</span>之后，无法再修改front的值</span><br><span class="line">        int temp = arr[front];</span><br><span class="line">        front = (front + 1) % (maxSize);</span><br><span class="line">        <span class="built_in">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示队列的所有数据</span><br><span class="line">    public void <span class="function"><span class="title">showQueue</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列为空，没有数据！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        //从front开始遍历，遍历的元素个数为：(rear+maxSize-front)%maxSize</span><br><span class="line">        <span class="keyword">for</span> (int a = front; a &lt; front + size(); a++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;arr[&quot;</span> + a % maxSize + <span class="string">&quot;]=&quot;</span> + arr[a % maxSize] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //System.out.println(<span class="string">&quot;arr[&quot;</span> + a % maxSize + <span class="string">&quot;]=&quot;</span> + arr[a % maxSize] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    //System.out.printf(<span class="string">&quot;arr[%d]=%d\n&quot;</span>, a % maxSize, arr[a % maxSize])</span><br><span class="line"></span><br><span class="line">    //求出当前队列有效数据个数</span><br><span class="line">    public int <span class="function"><span class="title">size</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> (rear + maxSize - front) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示队列的头数据（不是取出数据，仅仅是显示）</span><br><span class="line">    public int <span class="function"><span class="title">headQueue</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(<span class="string">&quot;队列为空，没有头数据！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><font color="#dd0000"></font><br /></p>
<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>以上内容为博主总结，用于日后复习与巩固，如果转载请注明来源，谢谢。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之单向链表-无排序</title>
    <url>/2021/09/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8-%E6%97%A0%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="单向链表（无排序）"><a href="#单向链表（无排序）" class="headerlink" title="单向链表（无排序）"></a>单向链表（无排序）</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1.链表是有序的列表。<br>2.链表是以节点的方式来存储，是链式存储。<br>3.每个节点包含data域、next域（指向下一节点）。<br>4.链表的各个节点不一定是连续存储。<br>5.链表分为带头节点的链表和没有头节点的链表，根据实际需求来确定。</p>
<span id="more"></span>

<h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="https://i.loli.net/2021/09/22/sz1aw5hSYVIWlKE.png" alt="链表.PNG"></p>
<p>以及单链表（带头节点）逻辑结构示意图如下：<br><img src="https://i.loli.net/2021/09/22/ajQwXIh83kTEOgz.png" alt="单链表（带头节点）逻辑结构示意图.png"></p>
<p>1.添加（创建）<br>1)先创建一个head头节点，作用是表示单链表的头。<br>2)后面每添加一个节点，就直接加入到链表的最后，因为是无排序的版本。<br>2.遍历<br>1)通过一个辅助变量（临时变量），帮助遍历整个链表。（具体代码中有说明和解释）</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.linkedlist;</span><br><span class="line"></span><br><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //进行测试</span><br><span class="line">        //先创建节点</span><br><span class="line">        HeroNode h1 = new HeroNode(1, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode h2 = new HeroNode(2, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode h3 = new HeroNode(3, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        SingleLinkedList singleLinkedList = new SingleLinkedList();</span><br><span class="line">        singleLinkedList.addNode(h1);</span><br><span class="line">        singleLinkedList.addNode(h2);</span><br><span class="line">        singleLinkedList.addNode(h3);</span><br><span class="line">        singleLinkedList.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个SingleLinkedList类，管理英雄</span><br><span class="line">class SingleLinkedList &#123;</span><br><span class="line">    //先初始化一个头结点，头节点不要动,不存放具体的数据</span><br><span class="line">    private HeroNode head = new HeroNode(0, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    //添加节点到单向链表</span><br><span class="line">    //思路:当不考虑编号顺序时</span><br><span class="line">    //1.找到当前链表的最后节点</span><br><span class="line">    //2.将最后这个节点的next指向新的节点,然后新节点的next变为null</span><br><span class="line">    public void addNode(HeroNode heroNode) &#123;</span><br><span class="line">        //因为头节点不能动，因此我们需要一个辅助变量temp</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line"></span><br><span class="line">        //遍历链表，找到最后</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //找到链表的最后</span><br><span class="line">            <span class="keyword">if</span> (temp.next == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果没有找到最后，将temp后移</span><br><span class="line">            temp = temp.next;//temp.next为temp的下一个节点</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //当退出<span class="keyword">while</span>循环时，temp就指向了链表的最后</span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示链表(遍历)</span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        //先判断链表是否为空</span><br><span class="line">        <span class="keyword">if</span> (head.next == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //因为头结点不能动，所以需要一个辅助变量来遍历</span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //判断是否到链表最后</span><br><span class="line">            <span class="keyword">if</span> (temp == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            //将temp后移，否则死循环</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个HeroNode， 每一个HeroNode对象就是一个节点</span><br><span class="line">class HeroNode &#123;</span><br><span class="line">    public int no;//编号</span><br><span class="line">    public String name;//名称</span><br><span class="line">    public String nickName;//昵称</span><br><span class="line">    public HeroNode next;//指向下一个节点</span><br><span class="line"></span><br><span class="line">    //构造器</span><br><span class="line">    public HeroNode(int no, String name, String nickname) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.nickName = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //为了显示方便，重写toString方法</span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;</span><span class="string">&#x27; +</span></span><br><span class="line"><span class="string">                &quot;, nickName=&#x27;</span><span class="string">&quot; + nickName + &#x27;\&#x27;&#x27; +</span></span><br><span class="line"><span class="string">                &#x27;&#125;&#x27;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>以上内容为博主总结，用于日后复习与巩固，如果转载请注明来源，谢谢。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之单向链表-有排序</title>
    <url>/2021/09/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8-%E6%9C%89%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="单向链表（有序版）"><a href="#单向链表（有序版）" class="headerlink" title="单向链表（有序版）"></a>单向链表（有序版）</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1.在单向链表（无排序）基础上，添加了addByOrder方法，实现了自动排序以及检测重复编号的功能。</p>
<span id="more"></span>

<h4 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h4><p>1.此种方式再添加节点（英雄）时，根据排名将英雄插入到指定位置（按照节点的no，如果有这个排名，则添加失败并给出提示）。<br>2.首先找到新添加节点的位置，通过辅助变量（指针），进而遍历。<br>3.核心实现代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">新节点.next = temp.next;</span><br><span class="line">temp.next = 新的节点;</span><br></pre></td></tr></table></figure>
<p>具体请参考代码实现</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.linkedlist;</span><br><span class="line"></span><br><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //进行测试</span><br><span class="line">        //先创建节点</span><br><span class="line">        HeroNode h1 = new HeroNode(1, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode h2 = new HeroNode(2, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode h3 = new HeroNode(3, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        SingleLinkedList singleLinkedList = new SingleLinkedList();</span><br><span class="line"></span><br><span class="line">        //无排序的方法添加</span><br><span class="line">//      singleLinkedList.addNode(h3);</span><br><span class="line">//      singleLinkedList.addNode(h1);</span><br><span class="line">//      singleLinkedList.addNode(h2);</span><br><span class="line"></span><br><span class="line">        //有排序的方法添加</span><br><span class="line">        singleLinkedList.addByOrder(h3);</span><br><span class="line">        singleLinkedList.addByOrder(h1);</span><br><span class="line">        singleLinkedList.addByOrder(h2);</span><br><span class="line"></span><br><span class="line">        //测试编号重复是否提示添加失败</span><br><span class="line">        singleLinkedList.addByOrder(h2);</span><br><span class="line"></span><br><span class="line">        //显示链表</span><br><span class="line">        singleLinkedList.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个SingleLinkedList类，管理英雄</span><br><span class="line">class SingleLinkedList &#123;</span><br><span class="line">    //先初始化一个头结点，头节点不要动,不存放具体的数据</span><br><span class="line">    private HeroNode head = new HeroNode(0, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    //添加节点到单向链表</span><br><span class="line">    //思路:当不考虑编号顺序时</span><br><span class="line">    //1.找到当前链表的最后节点</span><br><span class="line">    //2.将最后这个节点的next指向新的节点,然后新节点的next变为null</span><br><span class="line">    public void addNode(HeroNode heroNode) &#123;</span><br><span class="line">        //因为头节点不能动，因此我们需要一个辅助变量temp</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        //遍历链表，找到最后</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //找到链表的最后</span><br><span class="line">            <span class="keyword">if</span> (temp.next == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果没有找到最后，将temp后移</span><br><span class="line">            temp = temp.next;//temp.next为temp的下一个节点</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //当退出<span class="keyword">while</span>循环时，temp就指向了链表的最后</span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第二种添加节点的方法（有排序）,根据排名将英雄插入到指定位置（如果有这个排名，则添加失败并给出提示）</span><br><span class="line">    public void addByOrder(HeroNode heroNode) &#123;</span><br><span class="line">        //因为头节点不能动，所以通过一个辅助变量（指针）来帮助找到添加的位置</span><br><span class="line">        //因为是单链表，因此我们找到的temp是位于添加位置的前一个节点，否则添加不了</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        boolean flag = <span class="literal">false</span>;//用于记录英雄编号是否已经存在，默认不存在</span><br><span class="line"></span><br><span class="line">        //死循环遍历链表</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //判断是否为链表尾部</span><br><span class="line">            <span class="keyword">if</span> (temp.next == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断编号是否存在</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;英雄编号&quot;</span> + heroNode.no + <span class="string">&quot;已经存在，添加失败！&quot;</span>);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断temp.next是否大于heroNode.no，进而确定插入位置</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;    //这里不能写成temp.no &lt; heroNode.no</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //将temp后移，接着循环遍历</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //只有flag为<span class="literal">false</span>的时候才能添加新节点（英雄）</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示链表(遍历)</span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        //先判断链表是否为空</span><br><span class="line">        <span class="keyword">if</span> (head.next == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //因为头结点不能动，所以需要一个辅助变量来遍历</span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //判断是否到链表最后</span><br><span class="line">            <span class="keyword">if</span> (temp == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line"></span><br><span class="line">            //将temp后移，否则死循环</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个HeroNode， 每一个HeroNode对象就是一个节点</span><br><span class="line">class HeroNode &#123;</span><br><span class="line">    public int no;//编号</span><br><span class="line">    public String name;//名称</span><br><span class="line">    public String nickName;//昵称</span><br><span class="line">    public HeroNode next;//指向下一个节点</span><br><span class="line"></span><br><span class="line">    //构造器</span><br><span class="line">    public HeroNode(int no, String name, String nickname) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.nickName = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //为了显示方便，重写toString方法</span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;</span><span class="string">&#x27; +</span></span><br><span class="line"><span class="string">                &quot;, nickName=&#x27;</span><span class="string">&quot; + nickName + &#x27;\&#x27;&#x27; +</span></span><br><span class="line"><span class="string">                &#x27;&#125;&#x27;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>以上内容为博主总结，用于日后复习与巩固，如果转载请注明来源，谢谢。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之单向链表-修改</title>
    <url>/2021/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8-%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<h3 id="单向链表（修改功能）"><a href="#单向链表（修改功能）" class="headerlink" title="单向链表（修改功能）"></a>单向链表（修改功能）</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1.在单向链表（有排序）基础上，添加了update方法，实现了对链表节点（英雄）属性的修改。</p>
<span id="more"></span>

<h4 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h4><p>具体请参考代码实现。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.linkedlist;</span><br><span class="line"></span><br><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //进行测试</span><br><span class="line">        //先创建节点</span><br><span class="line">        HeroNode h1 = new HeroNode(1, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode h2 = new HeroNode(3, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode h3 = new HeroNode(5, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        HeroNode h4 = new HeroNode(2, <span class="string">&quot;测试&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        SingleLinkedList singleLinkedList = new SingleLinkedList();</span><br><span class="line"></span><br><span class="line">        //无排序的方法添加</span><br><span class="line">//      singleLinkedList.addNode(h3);</span><br><span class="line">//      singleLinkedList.addNode(h1);</span><br><span class="line">//      singleLinkedList.addNode(h2);</span><br><span class="line"></span><br><span class="line">        //有排序的方法添加</span><br><span class="line">        singleLinkedList.addByOrder(h3);</span><br><span class="line">        singleLinkedList.addByOrder(h1);</span><br><span class="line">        singleLinkedList.addByOrder(h2);</span><br><span class="line"></span><br><span class="line">        //修改节点属性</span><br><span class="line">        singleLinkedList.update(3, <span class="string">&quot;迪迦&quot;</span>, <span class="string">&quot;奥特曼&quot;</span>);</span><br><span class="line">        singleLinkedList.addByOrder(h4);</span><br><span class="line"></span><br><span class="line">        //测试编号重复是否提示添加失败</span><br><span class="line">        //singleLinkedList.addByOrder(h2);</span><br><span class="line">        //singleLinkedList.update(2,<span class="string">&quot;兽&quot;</span>,<span class="string">&quot;shi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        //显示链表</span><br><span class="line">        singleLinkedList.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个SingleLinkedList类，管理英雄</span><br><span class="line">class SingleLinkedList &#123;</span><br><span class="line">    //先初始化一个头结点，头节点不要动,不存放具体的数据</span><br><span class="line">    private HeroNode head = new HeroNode(0, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    //添加节点到单向链表</span><br><span class="line">    //思路:当不考虑编号顺序时</span><br><span class="line">    //1.找到当前链表的最后节点</span><br><span class="line">    //2.将最后这个节点的next指向新的节点,然后新节点的next变为null</span><br><span class="line">    public void addNode(HeroNode heroNode) &#123;</span><br><span class="line">        //因为头节点不能动，因此我们需要一个辅助变量temp</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        //遍历链表，找到最后</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //找到链表的最后</span><br><span class="line">            <span class="keyword">if</span> (temp.next == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果没有找到最后，将temp后移</span><br><span class="line">            temp = temp.next;//temp.next为temp的下一个节点</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //当退出<span class="keyword">while</span>循环时，temp就指向了链表的最后</span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第二种添加节点的方法（有排序）,根据排名将英雄插入到指定位置（如果有这个排名，则添加失败并给出提示）</span><br><span class="line">    public void addByOrder(HeroNode heroNode) &#123;</span><br><span class="line">        //因为头节点不能动，所以通过一个辅助变量（指针）来帮助找到添加的位置</span><br><span class="line">        //因为是单链表，因此我们找到的temp是位于添加位置的前一个节点，否则添加不了</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        boolean flag = <span class="literal">false</span>;//用于记录英雄编号是否已经存在，默认不存在</span><br><span class="line"></span><br><span class="line">        //死循环遍历链表</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //判断是否为链表尾部</span><br><span class="line">            <span class="keyword">if</span> (temp.next == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断编号是否存在</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;英雄编号&quot;</span> + heroNode.no + <span class="string">&quot;已经存在，添加失败！&quot;</span>);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断temp.next是否大于heroNode.no，进而确定插入位置</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;    //这里不能写成temp.no &lt; heroNode.no</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //将temp后移，接着循环遍历</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //只有flag为<span class="literal">false</span>的时候才能添加新节点（英雄）</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //修改节点（英雄）的信息，不能改编号no</span><br><span class="line">    public void update(int No, String name, String nickname) &#123;</span><br><span class="line">        //判断是否为空</span><br><span class="line">        <span class="keyword">if</span> (head.next == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //根据传进来的no编号，找到需要修改的辅助节点</span><br><span class="line">        //定义一个辅助变量</span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        boolean flag = <span class="literal">false</span>;//用于记录是否找到该编号的节点，默认为<span class="literal">false</span></span><br><span class="line">        //遍历链表</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //遍历完还没有找到</span><br><span class="line">            <span class="keyword">if</span> (temp == null) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;链表里没有所要修改的编号！&quot;</span>);</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //寻找到了no编号，将标志改为<span class="literal">true</span></span><br><span class="line">            <span class="keyword">if</span> (temp.no == No) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果没找到no，将temp后移</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = name;</span><br><span class="line">            temp.nickName = nickname;</span><br><span class="line">            System.out.println(<span class="string">&quot;已成功修改编号为：&quot;</span> + No + <span class="string">&quot;的节点信息！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示链表(遍历)</span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        //先判断链表是否为空</span><br><span class="line">        <span class="keyword">if</span> (head.next == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //因为头结点不能动，所以需要一个辅助变量来遍历</span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //判断是否到链表最后</span><br><span class="line">            <span class="keyword">if</span> (temp == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line"></span><br><span class="line">            //将temp后移，否则死循环</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个HeroNode， 每一个HeroNode对象就是一个节点</span><br><span class="line">class HeroNode &#123;</span><br><span class="line">    public int no;//编号</span><br><span class="line">    public String name;//名称</span><br><span class="line">    public String nickName;//昵称</span><br><span class="line">    public HeroNode next;//指向下一个节点</span><br><span class="line"></span><br><span class="line">    //构造器</span><br><span class="line">    public HeroNode(int no, String name, String nickname) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.nickName = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //为了显示方便，重写toString方法</span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;</span><span class="string">&#x27; +</span></span><br><span class="line"><span class="string">                &quot;, nickName=&#x27;</span><span class="string">&quot; + nickName + &#x27;\&#x27;&#x27; +</span></span><br><span class="line"><span class="string">                &#x27;&#125;&#x27;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>以上内容为博主总结，用于日后复习与巩固，如果转载请注明来源，谢谢。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之单向链表-删除</title>
    <url>/2021/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8-%E5%88%A0%E9%99%A4/</url>
    <content><![CDATA[<h3 id="单向链表（删除功能）"><a href="#单向链表（删除功能）" class="headerlink" title="单向链表（删除功能）"></a>单向链表（删除功能）</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1.在单向链表（有排序）基础上，添加了delNode方法，实现了对链表节点（英雄）的删除。</p>
<span id="more"></span>

<h4 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h4><p>具体请参考代码实现。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.linkedlist;</span><br><span class="line"></span><br><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //进行测试</span><br><span class="line">        //先创建节点</span><br><span class="line">        HeroNode h1 = new HeroNode(1, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode h2 = new HeroNode(3, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode h3 = new HeroNode(5, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        HeroNode h4 = new HeroNode(2, <span class="string">&quot;测试&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        SingleLinkedList singleLinkedList = new SingleLinkedList();</span><br><span class="line"></span><br><span class="line">        //无排序的方法添加</span><br><span class="line">//      singleLinkedList.addNode(h3);</span><br><span class="line">//      singleLinkedList.addNode(h1);</span><br><span class="line">//      singleLinkedList.addNode(h2);</span><br><span class="line"></span><br><span class="line">        //有排序的方法添加</span><br><span class="line">        singleLinkedList.addByOrder(h3);</span><br><span class="line">        singleLinkedList.addByOrder(h1);</span><br><span class="line">        singleLinkedList.addByOrder(h2);</span><br><span class="line"></span><br><span class="line">        //修改节点属性</span><br><span class="line">        singleLinkedList.update(3, <span class="string">&quot;迪迦&quot;</span>, <span class="string">&quot;奥特曼&quot;</span>);</span><br><span class="line">        singleLinkedList.addByOrder(h4);</span><br><span class="line"></span><br><span class="line">        //测试编号重复是否提示添加失败</span><br><span class="line">        //singleLinkedList.addByOrder(h2);</span><br><span class="line">        //singleLinkedList.update(2,<span class="string">&quot;兽&quot;</span>,<span class="string">&quot;shi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        //显示链表</span><br><span class="line">        singleLinkedList.show();</span><br><span class="line">        //间隔线</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">        //删除no为2的节点，再次显示链表</span><br><span class="line">        singleLinkedList.delNode(2);</span><br><span class="line">        singleLinkedList.show();</span><br><span class="line">        //间隔线</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">        //测试删除不存在的节点</span><br><span class="line">        singleLinkedList.delNode(9);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个SingleLinkedList类，管理英雄</span><br><span class="line">class SingleLinkedList &#123;</span><br><span class="line">    //先初始化一个头结点，头节点不要动,不存放具体的数据</span><br><span class="line">    private HeroNode head = new HeroNode(0, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    //添加节点到单向链表</span><br><span class="line">    //思路:当不考虑编号顺序时</span><br><span class="line">    //1.找到当前链表的最后节点</span><br><span class="line">    //2.将最后这个节点的next指向新的节点,然后新节点的next变为null</span><br><span class="line">    public void addNode(HeroNode heroNode) &#123;</span><br><span class="line">        //因为头节点不能动，因此我们需要一个辅助变量temp</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        //遍历链表，找到最后</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //找到链表的最后</span><br><span class="line">            <span class="keyword">if</span> (temp.next == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果没有找到最后，将temp后移</span><br><span class="line">            temp = temp.next;//temp.next为temp的下一个节点</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //当退出<span class="keyword">while</span>循环时，temp就指向了链表的最后</span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第二种添加节点的方法（有排序）,根据排名将英雄插入到指定位置（如果有这个排名，则添加失败并给出提示）</span><br><span class="line">    public void addByOrder(HeroNode heroNode) &#123;</span><br><span class="line">        //因为头节点不能动，所以通过一个辅助变量（指针）来帮助找到添加的位置</span><br><span class="line">        //因为是单链表，因此我们找到的temp是位于添加位置的前一个节点，否则添加不了</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        boolean flag = <span class="literal">false</span>;//用于记录英雄编号是否已经存在，默认不存在</span><br><span class="line"></span><br><span class="line">        //死循环遍历链表</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //判断是否为链表尾部</span><br><span class="line">            <span class="keyword">if</span> (temp.next == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断编号是否存在</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;英雄编号&quot;</span> + heroNode.no + <span class="string">&quot;已经存在，添加失败！&quot;</span>);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断temp.next是否大于heroNode.no，进而确定插入位置</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;    //这里不能写成temp.no &lt; heroNode.no</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //将temp后移，接着循环遍历</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //只有flag为<span class="literal">false</span>的时候才能添加新节点（英雄）</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //修改节点（英雄）的信息，不能改编号no</span><br><span class="line">    public void update(int No, String name, String nickname) &#123;</span><br><span class="line">        //判断是否为空</span><br><span class="line">        <span class="keyword">if</span> (head.next == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //根据传进来的no编号，找到需要修改的辅助节点</span><br><span class="line">        //定义一个辅助变量</span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        boolean flag = <span class="literal">false</span>;//用于记录是否找到该编号的节点，默认为<span class="literal">false</span></span><br><span class="line">        //遍历链表</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //遍历完还没有找到</span><br><span class="line">            <span class="keyword">if</span> (temp == null) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;链表里没有所要修改的编号！&quot;</span>);</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //寻找到了no编号，将标志改为<span class="literal">true</span></span><br><span class="line">            <span class="keyword">if</span> (temp.no == No) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果没找到no，将temp后移</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = name;</span><br><span class="line">            temp.nickName = nickname;</span><br><span class="line">            System.out.println(<span class="string">&quot;已成功修改编号为：&quot;</span> + No + <span class="string">&quot;的节点信息！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除节点</span><br><span class="line">    public void delNode(int No) &#123;</span><br><span class="line">        //定义一个标记，用于判断是否执行删除操作</span><br><span class="line">        boolean flag = <span class="literal">false</span>;</span><br><span class="line">        //定义一个辅助变量</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        //先判断链表是否为空，如果为空</span><br><span class="line">        <span class="keyword">if</span> (head.next == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            //如果不为空</span><br><span class="line">            <span class="keyword">if</span> (No == temp.next.no) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果没找到编号，将temp后移</span><br><span class="line">            temp = temp.next;</span><br><span class="line"></span><br><span class="line">            //如果编号不存在</span><br><span class="line">            <span class="keyword">if</span> (temp.next == null) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;你想删除的节点不存在！&quot;</span>);</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //进行删除操作</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">            System.out.println(<span class="string">&quot;已成功删除编号为：&quot;</span> + No + <span class="string">&quot;的节点！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示链表(遍历)</span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        //先判断链表是否为空</span><br><span class="line">        <span class="keyword">if</span> (head.next == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //因为头结点不能动，所以需要一个辅助变量来遍历</span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //判断是否到链表最后</span><br><span class="line">            <span class="keyword">if</span> (temp == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line"></span><br><span class="line">            //将temp后移，否则死循环</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个HeroNode， 每一个HeroNode对象就是一个节点</span><br><span class="line">class HeroNode &#123;</span><br><span class="line">    public int no;//编号</span><br><span class="line">    public String name;//名称</span><br><span class="line">    public String nickName;//昵称</span><br><span class="line">    public HeroNode next;//指向下一个节点</span><br><span class="line"></span><br><span class="line">    //构造器</span><br><span class="line">    public HeroNode(int no, String name, String nickname) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.nickName = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //为了显示方便，重写toString方法</span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;</span><span class="string">&#x27; +</span></span><br><span class="line"><span class="string">                &quot;, nickName=&#x27;</span><span class="string">&quot; + nickName + &#x27;\&#x27;&#x27; +</span></span><br><span class="line"><span class="string">                &#x27;&#125;&#x27;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
</search>
