<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo 双线部署到Coding和GitHub</title>
    <url>/2021/08/16/hexo-%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2%E5%88%B0Coding%E5%92%8CGitHub/</url>
    <content><![CDATA[<p>因为教程步骤繁琐，具体请参考:<a href="https://cloud.tencent.com/developer/article/1834005">https://cloud.tencent.com/developer/article/1834005</a></p>
]]></content>
  </entry>
  <entry>
    <title>Git Bash的基本命令</title>
    <url>/2021/07/31/Git%20Bash%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="第-1-个命令："><a href="#第-1-个命令：" class="headerlink" title="第 1 个命令："></a>第 1 个命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<p>在命令行窗口的光标处，输入git status命令，查看仓库的状态<br>注：在每个git操作之后，我们基本都会输入git status命令，查看仓库状态。这也从侧面说明了git status命令使用的频率之高，也建议大家在操作 Git 仓库的时候多使用git status命令，这能帮助我们实时了解仓库的状态，显然非常有用。</p>
<h3 id="第-2-个命令："><a href="#第-2-个命令：" class="headerlink" title="第 2 个命令："></a>第 2 个命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>在命令行窗口的光标处，输入git init命令，初始化 Git 仓库</p>
<h3 id="第-3-个命令："><a href="#第-3-个命令：" class="headerlink" title="第 3 个命令："></a>第 3 个命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add</span><br></pre></td></tr></table></figure>
<p>在命令行窗口的光标处，输入git add hit.txt命令，将hit.txt文件添加到 Git 仓库<br>注：git add命令并没有把文件提交到 Git 仓库，而是把文件添加到了「临时缓冲区」，这个命令有效防止了我们错误提交的可能性。</p>
<span id="more"></span>

<h3 id="第-4-个命令："><a href="#第-4-个命令：" class="headerlink" title="第 4 个命令："></a>第 4 个命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure>
<p>在命令行窗口的光标处，输入git commit -m “text commit”命令，将hit.txt文件提交到 Git 仓库<br>其中commit表示提交，-m表示提交信息，提交信息写在双引号””内。</p>
<h3 id="第-5-个命令："><a href="#第-5-个命令：" class="headerlink" title="第 5 个命令："></a>第 5 个命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<p>在命令行窗口的光标处，输入git log”命令，打印 Git 仓库提交日志<br>注：提交记录的内容包括Author提交作者、Date提交日期和提交信息。</p>
<h3 id="第-6-个命令："><a href="#第-6-个命令：" class="headerlink" title="第 6 个命令："></a>第 6 个命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
<p>在命令行窗口的光标处，输入git branch命令，查看 Git 仓库的分支情况<br>注：*号表示“当前所在的分支”，或者看后边蓝色小括号即为当前所在分支。</p>
<h3 id="第-7-个命令："><a href="#第-7-个命令：" class="headerlink" title="第 7 个命令："></a>第 7 个命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout</span><br></pre></td></tr></table></figure>
<p>在命令行窗口的光标处，输入git checkout a命令，切换到a分支</p>
<h3 id="第-8-个命令："><a href="#第-8-个命令：" class="headerlink" title="第 8 个命令："></a>第 8 个命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge</span><br></pre></td></tr></table></figure>
<p>切换到master分支，然后输入git merge a命令，将a分支合并到master分支<br>注：在合并分支的时候，要考虑到两个分支是否有冲突，如果有冲突，则不能直接合并，需要先解决冲突；反之，则可以直接合并。</p>
<h3 id="第-9-个命令："><a href="#第-9-个命令：" class="headerlink" title="第 9 个命令："></a>第 9 个命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d &amp; git branch -D</span><br></pre></td></tr></table></figure>
<p>在命令行窗口的光标处，输入git branch -d a命令，删除a分支<br>注：有的时候，通过git branch -d命令可以出现删除不了现象，例如分支a的代码没有合并到主分支等，这时如果我们一定要删除该分支，那么我们可以通过命令git branch -D进行强制删除。</p>
<h3 id="第-10-个命令："><a href="#第-10-个命令：" class="headerlink" title="第 10 个命令："></a>第 10 个命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure>
<p>在命令行窗口的光标处，输入git tag v1.0命令，为当前分支添加标签，通过命令git tag即可查看标签记录，通过命令git checkout v1.0即可切换到该标签下的代码状态</p>
<p><font color="#dd0000">（注：在我们进行任何的git操作之前，我们都得先切换到 Git 的仓库目录。换言之，我们得到先进入到（我们定义的）Git 仓库的最顶层文件目录下，然后从此目录中进入 Git Bash，这样之后的操作才能顺利进行。如果是 Linux 操作系统，则可以直接cd到仓库目录。）</font><br /></p>
<p>注：原作者：GitHubPorn<br>链接：<a href="https://zhuanlan.zhihu.com/p/369486197">https://zhuanlan.zhihu.com/p/369486197</a><br>（博主在此基础上进行精简，摘取，修改）</p>
]]></content>
      <categories>
        <category>Git使用相关</category>
      </categories>
  </entry>
  <entry>
    <title>使用ubuntu，目录为中文的解决办法</title>
    <url>/2021/07/29/%E4%BD%BF%E7%94%A8ubuntu%EF%BC%8C%E7%9B%AE%E5%BD%95%E4%B8%BA%E4%B8%AD%E6%96%87%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>终端输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LANG=en_US</span><br></pre></td></tr></table></figure>
<p>并执行</p>
<p>终端输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xdg-user-dirs-gtk-update</span><br></pre></td></tr></table></figure>
<p>并执行，</p>
<p>弹出窗口，选择不再提示，并确认</p>
<p>终端输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LANG=zh_CN</span><br></pre></td></tr></table></figure>
<p>并执行</p>
<p>关闭终端并重启ubuntu</p>
]]></content>
      <categories>
        <category>杂项汇总</category>
      </categories>
  </entry>
  <entry>
    <title>hexo如何新建文章</title>
    <url>/2021/08/15/hexo%E5%A6%82%E4%BD%95%E6%96%B0%E5%BB%BA%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h3 id="1-新建文章"><a href="#1-新建文章" class="headerlink" title="1.新建文章"></a>1.新建文章</h3><h4 id="（1）输入命令"><a href="#（1）输入命令" class="headerlink" title="（1）输入命令"></a>（1）输入命令</h4><p>在hexo博客目录下，右键选择Git Bash Here,输入以下代码并回车：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;文章名字&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="（2）文章所在位置"><a href="#（2）文章所在位置" class="headerlink" title="（2）文章所在位置"></a>（2）文章所在位置</h4><p>在hexo博客目录下的/source/_posts/文件夹里，可以找到你新建的博客文件.md，直接打开编辑文章即可（使用Markdown语法）。传送门：<a href="https://www.appinn.com/markdown/">Markdown语法教程</a></p>
<h3 id="2-编辑文章"><a href="#2-编辑文章" class="headerlink" title="2.编辑文章"></a>2.编辑文章</h3><h4 id="（1）设置文章所属tags（标签）和categories（分类）"><a href="#（1）设置文章所属tags（标签）和categories（分类）" class="headerlink" title="（1）设置文章所属tags（标签）和categories（分类）"></a>（1）设置文章所属tags（标签）和categories（分类）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: hexo如何新建文章</span><br><span class="line">date: 2021-08-15 11:55:43</span><br><span class="line">tags: （设置标签的地方）</span><br><span class="line">categories: （设置分类的地方）</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p><font color="#dd0000">（注：设置属性的冒号后面要有一个空格，一定要注意！）</font><br /></p>
<h4 id="（2）设置阅读全文按钮"><a href="#（2）设置阅读全文按钮" class="headerlink" title="（2）设置阅读全文按钮"></a>（2）设置阅读全文按钮</h4><p>在文章中使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>
<p>之后的代码将不会被显示。</p>
<h3 id="3-将文章部署到Github"><a href="#3-将文章部署到Github" class="headerlink" title="3.将文章部署到Github"></a>3.将文章部署到Github</h3><p>（1）在Git中依次执行以下3行代码（3部曲）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo c</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>（每次执行3部曲的时候，都要进入Github仓库重新设置一下Page为你的域名，至于问什么会出现这种问题，我也不知道）</p>
<p>接下来访问自己的博客域名，就能看到新的文章了！</p>
]]></content>
      <categories>
        <category>hexo博客操作相关</category>
      </categories>
  </entry>
  <entry>
    <title>关于昨天尝试双线部署hexo</title>
    <url>/2021/08/17/%E5%85%B3%E4%BA%8E%E6%98%A8%E5%A4%A9%E5%B0%9D%E8%AF%95%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2hexo/</url>
    <content><![CDATA[<p>因为此博客是部署在Github上的，所以国内访问会比较慢，甚至无法访问，正好看到了将hexo双线部署在Github和Coding上，顺便也能让百度收录此博客，于是就尝试了一下，coding账号注册，新建项目，新建仓库，修改博客config文件，修改DNS解析，配置密匙，将Github解析改为境外访问等等…一气呵成，最后发现博客无法打开，因为网上的教程都是腾讯云开发平台的教程，好像是coding被腾讯收购了，而我用的又是coding，难免会有些设置不存在或者找不到，导致最终失败了，昨天也是弄了几个小时，头晕眼花，等过一段时间我再重新试一下。</p>
]]></content>
      <categories>
        <category>记录心情</category>
      </categories>
  </entry>
  <entry>
    <title>学习目标</title>
    <url>/2021/09/09/%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87/</url>
    <content><![CDATA[<h3 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h3><h4 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h4><p>1.继续学习数据结构与算法<br>2.复习javase<br>3.学习markdown语法<br>4.给博客添加评论功能（未完成）<br>5.百度好像还没收录我的博客，不知道哪里出了问题，有时间再弄一下（未完成）<br>6………</p>
<h4 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h4><p>1.继续学习数据结构与算法<br>2.复习javase<br>3.百度收录博客<br>4.美化博客（添加音乐分享）</p>
]]></content>
      <categories>
        <category>学习进度及目标</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之单向链表-修改</title>
    <url>/2021/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8-%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<h3 id="单向链表（修改功能）"><a href="#单向链表（修改功能）" class="headerlink" title="单向链表（修改功能）"></a>单向链表（修改功能）</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1.在单向链表（有排序）基础上，添加了update方法，实现了对链表结点（英雄）属性的修改。</p>
<span id="more"></span>

<h4 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h4><p>具体请参考代码实现。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.linkedlist;</span><br><span class="line"></span><br><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //进行测试</span><br><span class="line">        //先创建结点</span><br><span class="line">        HeroNode h1 = new HeroNode(1, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode h2 = new HeroNode(3, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode h3 = new HeroNode(5, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        HeroNode h4 = new HeroNode(2, <span class="string">&quot;测试&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        SingleLinkedList singleLinkedList = new SingleLinkedList();</span><br><span class="line"></span><br><span class="line">        //无排序的方法添加</span><br><span class="line">//      singleLinkedList.addNode(h3);</span><br><span class="line">//      singleLinkedList.addNode(h1);</span><br><span class="line">//      singleLinkedList.addNode(h2);</span><br><span class="line"></span><br><span class="line">        //有排序的方法添加</span><br><span class="line">        singleLinkedList.addByOrder(h3);</span><br><span class="line">        singleLinkedList.addByOrder(h1);</span><br><span class="line">        singleLinkedList.addByOrder(h2);</span><br><span class="line"></span><br><span class="line">        //修改结点属性</span><br><span class="line">        singleLinkedList.update(3, <span class="string">&quot;迪迦&quot;</span>, <span class="string">&quot;奥特曼&quot;</span>);</span><br><span class="line">        singleLinkedList.addByOrder(h4);</span><br><span class="line"></span><br><span class="line">        //测试编号重复是否提示添加失败</span><br><span class="line">        //singleLinkedList.addByOrder(h2);</span><br><span class="line">        //singleLinkedList.update(2,<span class="string">&quot;兽&quot;</span>,<span class="string">&quot;shi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        //显示链表</span><br><span class="line">        singleLinkedList.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个SingleLinkedList类，管理英雄</span><br><span class="line">class SingleLinkedList &#123;</span><br><span class="line">    //先初始化一个头结点，头结点不要动,不存放具体的数据</span><br><span class="line">    private HeroNode head = new HeroNode(0, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    //添加结点到单向链表</span><br><span class="line">    //思路:当不考虑编号顺序时</span><br><span class="line">    //1.找到当前链表的最后结点</span><br><span class="line">    //2.将最后这个结点的next指向新的结点,然后新结点的next变为null</span><br><span class="line">    public void addNode(HeroNode heroNode) &#123;</span><br><span class="line">        //因为头结点不能动，因此我们需要一个辅助变量temp</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        //遍历链表，找到最后</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //找到链表的最后</span><br><span class="line">            <span class="keyword">if</span> (temp.next == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果没有找到最后，将temp后移</span><br><span class="line">            temp = temp.next;//temp.next为temp的下一个结点</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //当退出<span class="keyword">while</span>循环时，temp就指向了链表的最后</span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第二种添加结点的方法（有排序）,根据排名将英雄插入到指定位置（如果有这个排名，则添加失败并给出提示）</span><br><span class="line">    public void addByOrder(HeroNode heroNode) &#123;</span><br><span class="line">        //因为头结点不能动，所以通过一个辅助变量（指针）来帮助找到添加的位置</span><br><span class="line">        //因为是单链表，因此我们找到的temp是位于添加位置的前一个结点，否则添加不了</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        boolean flag = <span class="literal">false</span>;//用于记录英雄编号是否已经存在，默认不存在</span><br><span class="line"></span><br><span class="line">        //死循环遍历链表</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //判断是否为链表尾部</span><br><span class="line">            <span class="keyword">if</span> (temp.next == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断编号是否存在</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;英雄编号&quot;</span> + heroNode.no + <span class="string">&quot;已经存在，添加失败！&quot;</span>);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断temp.next是否大于heroNode.no，进而确定插入位置</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;    //这里不能写成temp.no &lt; heroNode.no</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //将temp后移，接着循环遍历</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //只有flag为<span class="literal">false</span>的时候才能添加新结点（英雄）</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //修改结点（英雄）的信息，不能改编号no</span><br><span class="line">    public void update(int No, String name, String nickname) &#123;</span><br><span class="line">        //判断是否为空</span><br><span class="line">        <span class="keyword">if</span> (head.next == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //根据传进来的no编号，找到需要修改的辅助结点</span><br><span class="line">        //定义一个辅助变量</span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        boolean flag = <span class="literal">false</span>;//用于记录是否找到该编号的结点，默认为<span class="literal">false</span></span><br><span class="line">        //遍历链表</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //遍历完还没有找到</span><br><span class="line">            <span class="keyword">if</span> (temp == null) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;链表里没有所要修改的编号！&quot;</span>);</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //寻找到了no编号，将标志改为<span class="literal">true</span></span><br><span class="line">            <span class="keyword">if</span> (temp.no == No) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果没找到no，将temp后移</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = name;</span><br><span class="line">            temp.nickName = nickname;</span><br><span class="line">            System.out.println(<span class="string">&quot;已成功修改编号为：&quot;</span> + No + <span class="string">&quot;的结点信息！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示链表(遍历)</span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        //先判断链表是否为空</span><br><span class="line">        <span class="keyword">if</span> (head.next == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //因为头结点不能动，所以需要一个辅助变量来遍历</span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //判断是否到链表最后</span><br><span class="line">            <span class="keyword">if</span> (temp == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line"></span><br><span class="line">            //将temp后移，否则死循环</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个HeroNode， 每一个HeroNode对象就是一个结点</span><br><span class="line">class HeroNode &#123;</span><br><span class="line">    public int no;//编号</span><br><span class="line">    public String name;//名称</span><br><span class="line">    public String nickName;//昵称</span><br><span class="line">    public HeroNode next;//指向下一个结点</span><br><span class="line"></span><br><span class="line">    //构造器</span><br><span class="line">    public HeroNode(int no, String name, String nickname) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.nickName = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //为了显示方便，重写toString方法</span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;</span><span class="string">&#x27; +</span></span><br><span class="line"><span class="string">                &quot;, nickName=&#x27;</span><span class="string">&quot; + nickName + &#x27;\&#x27;&#x27; +</span></span><br><span class="line"><span class="string">                &#x27;&#125;&#x27;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>以上内容为博主总结，用于日后复习与巩固，如果转载请注明来源，谢谢。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>学习进度</title>
    <url>/2021/08/22/%E5%AD%A6%E4%B9%A0%E8%BF%9B%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h3><h4 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h4><p>1.将hexo博客进行了双线部署。<br>2.将博客提交到百度收录。</p>
<h4 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h4><p>1.学习队列<br>2.学习环形队列</p>
<h4 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h4><p>1.学习单链表（无序）<br>2.学习单链表（有序）<br>3.学习双向链表(无序，有序)</p>
]]></content>
      <categories>
        <category>学习进度及目标</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之单向链表-无排序</title>
    <url>/2021/09/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8-%E6%97%A0%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="单向链表（无排序）"><a href="#单向链表（无排序）" class="headerlink" title="单向链表（无排序）"></a>单向链表（无排序）</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1.链表是有序的列表。<br>2.链表是以结点的方式来存储，是链式存储。<br>3.每个结点包含data域、next域（指向下一结点）。<br>4.链表的各个结点不一定是连续存储。<br>5.链表分为带头结点的链表和没有头结点的链表，根据实际需求来确定。</p>
<span id="more"></span>

<h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="https://i.loli.net/2021/09/22/sz1aw5hSYVIWlKE.png" alt="链表.PNG"></p>
<p>以及单链表（带头结点）逻辑结构示意图如下：<br><img src="https://i.loli.net/2021/09/22/ajQwXIh83kTEOgz.png" alt="单链表（带头结点）逻辑结构示意图.png"></p>
<p>1.添加（创建）<br>1)先创建一个head头结点，作用是表示单链表的头。<br>2)后面每添加一个结点，就直接加入到链表的最后，因为是无排序的版本。<br>2.遍历<br>1)通过一个辅助变量（临时变量），帮助遍历整个链表。（具体代码中有说明和解释）</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.linkedlist;</span><br><span class="line"></span><br><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //进行测试</span><br><span class="line">        //先创建结点</span><br><span class="line">        HeroNode h1 = new HeroNode(1, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode h2 = new HeroNode(2, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode h3 = new HeroNode(3, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        SingleLinkedList singleLinkedList = new SingleLinkedList();</span><br><span class="line">        singleLinkedList.addNode(h1);</span><br><span class="line">        singleLinkedList.addNode(h2);</span><br><span class="line">        singleLinkedList.addNode(h3);</span><br><span class="line">        singleLinkedList.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个SingleLinkedList类，管理英雄</span><br><span class="line">class SingleLinkedList &#123;</span><br><span class="line">    //先初始化一个头结点，头结点不要动,不存放具体的数据</span><br><span class="line">    private HeroNode head = new HeroNode(0, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    //添加结点到单向链表</span><br><span class="line">    //思路:当不考虑编号顺序时</span><br><span class="line">    //1.找到当前链表的最后结点</span><br><span class="line">    //2.将最后这个结点的next指向新的结点,然后新结点的next变为null</span><br><span class="line">    public void addNode(HeroNode heroNode) &#123;</span><br><span class="line">        //因为头结点不能动，因此我们需要一个辅助变量temp</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line"></span><br><span class="line">        //遍历链表，找到最后</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //找到链表的最后</span><br><span class="line">            <span class="keyword">if</span> (temp.next == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果没有找到最后，将temp后移</span><br><span class="line">            temp = temp.next;//temp.next为temp的下一个结点</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //当退出<span class="keyword">while</span>循环时，temp就指向了链表的最后</span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示链表(遍历)</span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        //先判断链表是否为空</span><br><span class="line">        <span class="keyword">if</span> (head.next == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //因为头结点不能动，所以需要一个辅助变量来遍历</span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //判断是否到链表最后</span><br><span class="line">            <span class="keyword">if</span> (temp == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            //将temp后移，否则死循环</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个HeroNode， 每一个HeroNode对象就是一个结点</span><br><span class="line">class HeroNode &#123;</span><br><span class="line">    public int no;//编号</span><br><span class="line">    public String name;//名称</span><br><span class="line">    public String nickName;//昵称</span><br><span class="line">    public HeroNode next;//指向下一个结点</span><br><span class="line"></span><br><span class="line">    //构造器</span><br><span class="line">    public HeroNode(int no, String name, String nickname) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.nickName = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //为了显示方便，重写toString方法</span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;</span><span class="string">&#x27; +</span></span><br><span class="line"><span class="string">                &quot;, nickName=&#x27;</span><span class="string">&quot; + nickName + &#x27;\&#x27;&#x27; +</span></span><br><span class="line"><span class="string">                &#x27;&#125;&#x27;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>以上内容为博主总结，用于日后复习与巩固，如果转载请注明来源，谢谢。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之单向链表-删除</title>
    <url>/2021/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8-%E5%88%A0%E9%99%A4/</url>
    <content><![CDATA[<h3 id="单向链表（删除功能）"><a href="#单向链表（删除功能）" class="headerlink" title="单向链表（删除功能）"></a>单向链表（删除功能）</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1.在单向链表（有排序）基础上，添加了delNode方法，实现了对链表结点（英雄）的删除。</p>
<span id="more"></span>

<h4 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h4><p>1.先找到需要删除的结点的前一个结点。<br>2.temp.next=temp.next.next<br>3.被删除的结点，将不会有其他引用指向，会被垃圾回收机制回收。<br>具体请参考代码实现。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.linkedlist;</span><br><span class="line"></span><br><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //进行测试</span><br><span class="line">        //先创建结点</span><br><span class="line">        HeroNode h1 = new HeroNode(1, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode h2 = new HeroNode(3, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode h3 = new HeroNode(5, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        HeroNode h4 = new HeroNode(2, <span class="string">&quot;测试&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        SingleLinkedList singleLinkedList = new SingleLinkedList();</span><br><span class="line"></span><br><span class="line">        //无排序的方法添加</span><br><span class="line">//      singleLinkedList.addNode(h3);</span><br><span class="line">//      singleLinkedList.addNode(h1);</span><br><span class="line">//      singleLinkedList.addNode(h2);</span><br><span class="line"></span><br><span class="line">        //有排序的方法添加</span><br><span class="line">        singleLinkedList.addByOrder(h3);</span><br><span class="line">        singleLinkedList.addByOrder(h1);</span><br><span class="line">        singleLinkedList.addByOrder(h2);</span><br><span class="line"></span><br><span class="line">        //修改结点属性</span><br><span class="line">        singleLinkedList.update(3, <span class="string">&quot;迪迦&quot;</span>, <span class="string">&quot;奥特曼&quot;</span>);</span><br><span class="line">        singleLinkedList.addByOrder(h4);</span><br><span class="line"></span><br><span class="line">        //测试编号重复是否提示添加失败</span><br><span class="line">        //singleLinkedList.addByOrder(h2);</span><br><span class="line">        //singleLinkedList.update(2,<span class="string">&quot;兽&quot;</span>,<span class="string">&quot;shi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        //显示链表</span><br><span class="line">        singleLinkedList.show();</span><br><span class="line">        //间隔线</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">        //删除no为2的结点，再次显示链表</span><br><span class="line">        singleLinkedList.delNode(2);</span><br><span class="line">        singleLinkedList.show();</span><br><span class="line">        //间隔线</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">        //测试删除不存在的结点</span><br><span class="line">        singleLinkedList.delNode(9);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个SingleLinkedList类，管理英雄</span><br><span class="line">class SingleLinkedList &#123;</span><br><span class="line">    //先初始化一个头结点，头结点不要动,不存放具体的数据</span><br><span class="line">    private HeroNode head = new HeroNode(0, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    //添加结点到单向链表</span><br><span class="line">    //思路:当不考虑编号顺序时</span><br><span class="line">    //1.找到当前链表的最后结点</span><br><span class="line">    //2.将最后这个结点的next指向新的结点,然后新结点的next变为null</span><br><span class="line">    public void addNode(HeroNode heroNode) &#123;</span><br><span class="line">        //因为头结点不能动，因此我们需要一个辅助变量temp</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        //遍历链表，找到最后</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //找到链表的最后</span><br><span class="line">            <span class="keyword">if</span> (temp.next == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果没有找到最后，将temp后移</span><br><span class="line">            temp = temp.next;//temp.next为temp的下一个结点</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //当退出<span class="keyword">while</span>循环时，temp就指向了链表的最后</span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第二种添加结点的方法（有排序）,根据排名将英雄插入到指定位置（如果有这个排名，则添加失败并给出提示）</span><br><span class="line">    public void addByOrder(HeroNode heroNode) &#123;</span><br><span class="line">        //因为头结点不能动，所以通过一个辅助变量（指针）来帮助找到添加的位置</span><br><span class="line">        //因为是单链表，因此我们找到的temp是位于添加位置的前一个结点，否则添加不了</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        boolean flag = <span class="literal">false</span>;//用于记录英雄编号是否已经存在，默认不存在</span><br><span class="line"></span><br><span class="line">        //死循环遍历链表</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //判断是否为链表尾部</span><br><span class="line">            <span class="keyword">if</span> (temp.next == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断编号是否存在</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;英雄编号&quot;</span> + heroNode.no + <span class="string">&quot;已经存在，添加失败！&quot;</span>);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断temp.next是否大于heroNode.no，进而确定插入位置</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;    //这里不能写成temp.no &lt; heroNode.no</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //将temp后移，接着循环遍历</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //只有flag为<span class="literal">false</span>的时候才能添加新结点（英雄）</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //修改结点（英雄）的信息，不能改编号no</span><br><span class="line">    public void update(int No, String name, String nickname) &#123;</span><br><span class="line">        //判断是否为空</span><br><span class="line">        <span class="keyword">if</span> (head.next == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //根据传进来的no编号，找到需要修改的辅助结点</span><br><span class="line">        //定义一个辅助变量</span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        boolean flag = <span class="literal">false</span>;//用于记录是否找到该编号的结点，默认为<span class="literal">false</span></span><br><span class="line">        //遍历链表</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //遍历完还没有找到</span><br><span class="line">            <span class="keyword">if</span> (temp == null) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;链表里没有所要修改的编号！&quot;</span>);</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //寻找到了no编号，将标志改为<span class="literal">true</span></span><br><span class="line">            <span class="keyword">if</span> (temp.no == No) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果没找到no，将temp后移</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = name;</span><br><span class="line">            temp.nickName = nickname;</span><br><span class="line">            System.out.println(<span class="string">&quot;已成功修改编号为：&quot;</span> + No + <span class="string">&quot;的结点信息！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除结点</span><br><span class="line">    public void delNode(int No) &#123;</span><br><span class="line">        //定义一个标记，用于判断是否执行删除操作</span><br><span class="line">        boolean flag = <span class="literal">false</span>;</span><br><span class="line">        //定义一个辅助变量</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        //先判断链表是否为空，如果为空</span><br><span class="line">        <span class="keyword">if</span> (head.next == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            //如果不为空</span><br><span class="line">            <span class="keyword">if</span> (No == temp.next.no) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果没找到编号，将temp后移</span><br><span class="line">            temp = temp.next;</span><br><span class="line"></span><br><span class="line">            //如果编号不存在</span><br><span class="line">            <span class="keyword">if</span> (temp.next == null) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;你想删除的结点不存在！&quot;</span>);</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //进行删除操作</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">            System.out.println(<span class="string">&quot;已成功删除编号为：&quot;</span> + No + <span class="string">&quot;的结点！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示链表(遍历)</span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        //先判断链表是否为空</span><br><span class="line">        <span class="keyword">if</span> (head.next == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //因为头结点不能动，所以需要一个辅助变量来遍历</span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //判断是否到链表最后</span><br><span class="line">            <span class="keyword">if</span> (temp == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line"></span><br><span class="line">            //将temp后移，否则死循环</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个HeroNode， 每一个HeroNode对象就是一个结点</span><br><span class="line">class HeroNode &#123;</span><br><span class="line">    public int no;//编号</span><br><span class="line">    public String name;//名称</span><br><span class="line">    public String nickName;//昵称</span><br><span class="line">    public HeroNode next;//指向下一个结点</span><br><span class="line"></span><br><span class="line">    //构造器</span><br><span class="line">    public HeroNode(int no, String name, String nickname) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.nickName = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //为了显示方便，重写toString方法</span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;</span><span class="string">&#x27; +</span></span><br><span class="line"><span class="string">                &quot;, nickName=&#x27;</span><span class="string">&quot; + nickName + &#x27;\&#x27;&#x27; +</span></span><br><span class="line"><span class="string">                &#x27;&#125;&#x27;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>以上内容为博主总结，用于日后复习与巩固，如果转载请注明来源，谢谢。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之单向链表-面试题</title>
    <url>/2021/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8-%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="单向链表（面试题）"><a href="#单向链表（面试题）" class="headerlink" title="单向链表（面试题）"></a>单向链表（面试题）</h3><p><font color="#dd0000">配合之前文章阅读</font><br /></p>
<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1.求链表有几个有效结点<br>2.求倒数第k个结点<br>3.反转链表</p>
<span id="more"></span>

<h5 id="求链表有几个有效结点"><a href="#求链表有几个有效结点" class="headerlink" title="求链表有几个有效结点"></a>求链表有几个有效结点</h5><p>代码实现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//返回链表中有几个有效结点的方法</span><br><span class="line">    public int getLength(HeroNode head) &#123;</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        int length = 0;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next != null) &#123;</span><br><span class="line">                length++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="求倒数第k个结点"><a href="#求倒数第k个结点" class="headerlink" title="求倒数第k个结点"></a>求倒数第k个结点</h5><p>代码实现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//查找单链表中的倒数第k个结点</span><br><span class="line">    public HeroNode getKnode(HeroNode head, int k) &#123;</span><br><span class="line">        //计数器</span><br><span class="line">        int counter = 0;</span><br><span class="line">        //判断单链表是否为空</span><br><span class="line">        <span class="keyword">if</span> (head.next == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果不为空，求总结点的个数size</span><br><span class="line">        int size = getLength(head);</span><br><span class="line"></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        //遍历单链表</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &lt;= 0 || k &gt; size) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;输入数值不合法！&quot;</span>);</span><br><span class="line">                <span class="built_in">return</span> null;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (counter == size - k) &#123;</span><br><span class="line">                <span class="built_in">return</span> temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h5><p><img src="https://i.loli.net/2021/10/10/mh3Kd5zBMRHUrc6.png" alt="链表反转1.2步.png"><br><img src="https://i.loli.net/2021/10/10/qvrQCc7AmReVWTZ.png" alt="链表反转3.4步.png"></p>
<p>代码实现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//反转链表</span><br><span class="line">    public void reverseLinkList(HeroNode head) &#123;</span><br><span class="line">        //判断单链表是否没有结点或只有一个结点</span><br><span class="line">        <span class="keyword">if</span> (head.next == null || head.next.next == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;单链表没有结点或只有一个结点，无需反转！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        //定义一个辅助变量,帮助我们遍历原来的链表</span><br><span class="line">        HeroNode cur = head.next;</span><br><span class="line">        HeroNode next = null;//指向当前结点（cur）的下一个结点，防止链表断开</span><br><span class="line">        //创建新的头结点</span><br><span class="line">        HeroNode reverseHead = new HeroNode(0, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        //遍历原来的链表，每遍历一个结点，就将其取出，并放在新链表reverseHead的最前端</span><br><span class="line">        <span class="keyword">while</span> (cur != null) &#123;</span><br><span class="line">            next = cur.next;//将next指向cur的下一个结点</span><br><span class="line">            cur.next = reverseHead.next;//将cur插入到reverseHead的前面</span><br><span class="line">            reverseHead.next = cur;//将reseverhead与cur连接</span><br><span class="line">            cur = next;//将cur后移</span><br><span class="line">        &#125;</span><br><span class="line">        //将head指向reseverHead的第一个结点</span><br><span class="line">        head.next = reverseHead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>以上内容为博主总结，用于日后复习与巩固，如果转载请注明来源，谢谢。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之单向链表-有排序</title>
    <url>/2021/09/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8-%E6%9C%89%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="单向链表（有序版）"><a href="#单向链表（有序版）" class="headerlink" title="单向链表（有序版）"></a>单向链表（有序版）</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1.在单向链表（无排序）基础上，添加了addByOrder方法，实现了自动排序以及检测重复编号的功能。</p>
<span id="more"></span>

<h4 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h4><p>1.此种方式再添加结点（英雄）时，根据排名将英雄插入到指定位置（按照结点的no，如果有这个排名，则添加失败并给出提示）。<br>2.首先找到新添加结点的位置，通过辅助变量（指针），进而遍历。<br>3.核心实现代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">新结点.next = temp.next;</span><br><span class="line">temp.next = 新的结点;</span><br></pre></td></tr></table></figure>
<p>具体请参考代码实现</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.linkedlist;</span><br><span class="line"></span><br><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //进行测试</span><br><span class="line">        //先创建结点</span><br><span class="line">        HeroNode h1 = new HeroNode(1, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode h2 = new HeroNode(2, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode h3 = new HeroNode(3, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        SingleLinkedList singleLinkedList = new SingleLinkedList();</span><br><span class="line"></span><br><span class="line">        //无排序的方法添加</span><br><span class="line">//      singleLinkedList.addNode(h3);</span><br><span class="line">//      singleLinkedList.addNode(h1);</span><br><span class="line">//      singleLinkedList.addNode(h2);</span><br><span class="line"></span><br><span class="line">        //有排序的方法添加</span><br><span class="line">        singleLinkedList.addByOrder(h3);</span><br><span class="line">        singleLinkedList.addByOrder(h1);</span><br><span class="line">        singleLinkedList.addByOrder(h2);</span><br><span class="line"></span><br><span class="line">        //测试编号重复是否提示添加失败</span><br><span class="line">        singleLinkedList.addByOrder(h2);</span><br><span class="line"></span><br><span class="line">        //显示链表</span><br><span class="line">        singleLinkedList.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个SingleLinkedList类，管理英雄</span><br><span class="line">class SingleLinkedList &#123;</span><br><span class="line">    //先初始化一个头结点，头结点不要动,不存放具体的数据</span><br><span class="line">    private HeroNode head = new HeroNode(0, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    //添加结点到单向链表</span><br><span class="line">    //思路:当不考虑编号顺序时</span><br><span class="line">    //1.找到当前链表的最后结点</span><br><span class="line">    //2.将最后这个结点的next指向新的结点,然后新结点的next变为null</span><br><span class="line">    public void addNode(HeroNode heroNode) &#123;</span><br><span class="line">        //因为头结点不能动，因此我们需要一个辅助变量temp</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        //遍历链表，找到最后</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //找到链表的最后</span><br><span class="line">            <span class="keyword">if</span> (temp.next == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果没有找到最后，将temp后移</span><br><span class="line">            temp = temp.next;//temp.next为temp的下一个结点</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //当退出<span class="keyword">while</span>循环时，temp就指向了链表的最后</span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第二种添加结点的方法（有排序）,根据排名将英雄插入到指定位置（如果有这个排名，则添加失败并给出提示）</span><br><span class="line">    public void addByOrder(HeroNode heroNode) &#123;</span><br><span class="line">        //因为头结点不能动，所以通过一个辅助变量（指针）来帮助找到添加的位置</span><br><span class="line">        //因为是单链表，因此我们找到的temp是位于添加位置的前一个结点，否则添加不了</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        boolean flag = <span class="literal">false</span>;//用于记录英雄编号是否已经存在，默认不存在</span><br><span class="line"></span><br><span class="line">        //死循环遍历链表</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //判断是否为链表尾部</span><br><span class="line">            <span class="keyword">if</span> (temp.next == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断编号是否存在</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;英雄编号&quot;</span> + heroNode.no + <span class="string">&quot;已经存在，添加失败！&quot;</span>);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断temp.next是否大于heroNode.no，进而确定插入位置</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;    //这里不能写成temp.no &lt; heroNode.no</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //将temp后移，接着循环遍历</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //只有flag为<span class="literal">false</span>的时候才能添加新结点（英雄）</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示链表(遍历)</span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        //先判断链表是否为空</span><br><span class="line">        <span class="keyword">if</span> (head.next == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //因为头结点不能动，所以需要一个辅助变量来遍历</span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //判断是否到链表最后</span><br><span class="line">            <span class="keyword">if</span> (temp == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line"></span><br><span class="line">            //将temp后移，否则死循环</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个HeroNode， 每一个HeroNode对象就是一个结点</span><br><span class="line">class HeroNode &#123;</span><br><span class="line">    public int no;//编号</span><br><span class="line">    public String name;//名称</span><br><span class="line">    public String nickName;//昵称</span><br><span class="line">    public HeroNode next;//指向下一个结点</span><br><span class="line"></span><br><span class="line">    //构造器</span><br><span class="line">    public HeroNode(int no, String name, String nickname) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.nickName = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //为了显示方便，重写toString方法</span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;</span><span class="string">&#x27; +</span></span><br><span class="line"><span class="string">                &quot;, nickName=&#x27;</span><span class="string">&quot; + nickName + &#x27;\&#x27;&#x27; +</span></span><br><span class="line"><span class="string">                &#x27;&#125;&#x27;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>以上内容为博主总结，用于日后复习与巩固，如果转载请注明来源，谢谢。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之双向链表</title>
    <url>/2021/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><h4 id="基本介绍-配合之前文章阅读"><a href="#基本介绍-配合之前文章阅读" class="headerlink" title="基本介绍(配合之前文章阅读)"></a>基本介绍(<font color="#dd0000">配合之前文章阅读</font><br />)</h4><p>1.因为和单向链表大同小异（多了一个pre属性，指向前一个结点），所以将双向链表的遍历，添加，修改，删除写在了同一篇文章。<br>2.遍历show：方法和单链表一样，区别是既可以向前倾，也可以向后查找。<br>3.添加addNode（默认添加到链表最后，无排序）：<br>1)先找到双向链表最后的这个结点<br>2)temp.next=HeroNode；<br>3)HeroNode.pre=temp；<br>4.添加addByOrder：(按照结点编号属性排序)<br>见代码实现</p>
<span id="more"></span>

<p>4.修改update：思路和单链表一样<br>5.删除delete：<br>1)因为是双向链表，所以可以实现自我删除某个结点。<br>2)直接找到要删除的结点<br>3)temp.pre.next=temp.next;<br>4)temp.next.pre=temp.pre;</p>
<h4 id="单向链表缺点"><a href="#单向链表缺点" class="headerlink" title="单向链表缺点"></a>单向链表缺点</h4><p>1.单向链表查找方向只能是一个方向，双向链表可以向前查找也可以向后查找。<br>2.单向链表不能自我删除，需要依靠辅助结点，双向链表可以自我删除，所以单向链表删除结点是，总是要找到temp<font color="#dd0000">(temp是待删结点的前一个结点)</font><br /></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.linkedlist;</span><br><span class="line"></span><br><span class="line">public class DoubleLinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HeroNode2 h1 = new HeroNode2(1, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode2 h2 = new HeroNode2(3, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode2 h3 = new HeroNode2(5, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        HeroNode2 h4 = new HeroNode2(2, <span class="string">&quot;测试&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();</span><br><span class="line">        //doubleLinkedList.addNode(h1);</span><br><span class="line">        //doubleLinkedList.addNode(h2);</span><br><span class="line">        //doubleLinkedList.addNode(h3);</span><br><span class="line">        //doubleLinkedList.addNode(h4);</span><br><span class="line">        doubleLinkedList.addByOrder(h4);</span><br><span class="line">        //doubleLinkedList.addNode(h1);</span><br><span class="line">        doubleLinkedList.addByOrder(h1);</span><br><span class="line">        doubleLinkedList.addByOrder(h2);</span><br><span class="line">        doubleLinkedList.addByOrder(h2);</span><br><span class="line">        doubleLinkedList.addByOrder(h3);</span><br><span class="line"></span><br><span class="line">        //展示链表</span><br><span class="line">        doubleLinkedList.show();</span><br><span class="line">        /*//间隔线</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">        //测试修改结点属性功能</span><br><span class="line">        doubleLinkedList.update(1, <span class="string">&quot;奥特曼&quot;</span>, <span class="string">&quot;打怪兽&quot;</span>);</span><br><span class="line">        doubleLinkedList.show();</span><br><span class="line">        //间隔线</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">        //测试删除结点</span><br><span class="line">        doubleLinkedList.delete(3);</span><br><span class="line">        //测试删除最后结点</span><br><span class="line">        doubleLinkedList.delete(2);</span><br><span class="line">        //测试重复删除同一结点</span><br><span class="line">        doubleLinkedList.delete(3);</span><br><span class="line">        //测试删除不存在结点</span><br><span class="line">        doubleLinkedList.delete(6);</span><br><span class="line">        //展示链表</span><br><span class="line">        doubleLinkedList.show();</span><br><span class="line">        //间隔线</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);*/</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//创建一个双向链表的类</span><br><span class="line">class DoubleLinkedList &#123;</span><br><span class="line">    //初始化一个头结点</span><br><span class="line">    private HeroNode2 head = new HeroNode2(0, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    //返回一个头结点</span><br><span class="line">    public HeroNode2 <span class="function"><span class="title">getHead</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //双向链表添加结点（无序）</span><br><span class="line">    public void addNode(HeroNode2 heroNode2) &#123;</span><br><span class="line">        HeroNode2 temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp.next != null) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heroNode2.no == temp.next.no) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;链表中已经存在编号为：&quot;</span> + heroNode2.no + <span class="string">&quot;的结点了，添加失败！&quot;</span>);</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = heroNode2;</span><br><span class="line">        heroNode2.pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //双向链表添加结点（有序）</span><br><span class="line">    public void addByOrder(HeroNode2 heroNode2) &#123;</span><br><span class="line">        HeroNode2 temp = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //添加结点核心代码</span><br><span class="line">            <span class="keyword">if</span> (heroNode2.no == temp.no) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;链表中已存在编号为：&quot;</span> + heroNode2.no + <span class="string">&quot;的结点了，添加失败！&quot;</span>);</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //判断是否为链表尾部</span><br><span class="line">            <span class="keyword">if</span> (temp.next == null) &#123;</span><br><span class="line">                temp.next = heroNode2;</span><br><span class="line">                heroNode2.pre = temp;</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (heroNode2.no &lt; temp.next.no) &#123;</span><br><span class="line">                heroNode2.next = temp.next;</span><br><span class="line">                temp.next.pre = heroNode2;</span><br><span class="line">                heroNode2.pre = temp;</span><br><span class="line">                temp.next = heroNode2;</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //修改双向链表结点信息</span><br><span class="line">    public void update(int no, String name, String nickname) &#123;</span><br><span class="line">        HeroNode2 temp = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == no) &#123;</span><br><span class="line">                temp.name = name;</span><br><span class="line">                temp.nickname = nickname;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果遍历到最后结点也没找到no结点</span><br><span class="line">            <span class="keyword">if</span> (temp.next == null) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;链表中不存在编号为&quot;</span> + no + <span class="string">&quot;的结点！&quot;</span>);</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //辅助变量后移</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //双向链表删除结点</span><br><span class="line">    //对于双向链表，只需要找到要被删除的结点，无需找到被删结点的前一个结点</span><br><span class="line">    //找到后，自我删除</span><br><span class="line">    public void delete(int no) &#123;</span><br><span class="line">        HeroNode2 temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //判断链表是否为空</span><br><span class="line">            <span class="keyword">if</span> (head.next == null) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //判断编号是否存在</span><br><span class="line">            <span class="keyword">if</span> (temp == null) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;链表中没有&quot;</span> + no + <span class="string">&quot;号结点！&quot;</span>);</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //删除双向链表结点的核心代码</span><br><span class="line">            <span class="keyword">if</span> (temp.no == no) &#123;</span><br><span class="line">                //如果删除的是最后结点，那么不能执行这条语句，不然会报空指针异常</span><br><span class="line">                <span class="keyword">if</span> (temp.next != null) &#123;</span><br><span class="line">                    temp.next.pre = temp.pre;</span><br><span class="line">                &#125;</span><br><span class="line">                temp.pre.next = temp.next;</span><br><span class="line">                System.out.println(<span class="string">&quot;已成功删除编号为：&quot;</span> + no + <span class="string">&quot;的结点！&quot;</span>);</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //继续遍历下一个结点</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示链表(遍历)</span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        //先判断链表是否为空</span><br><span class="line">        <span class="keyword">if</span> (head.next == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //因为头结点不能动，所以需要一个辅助变量来遍历</span><br><span class="line">        HeroNode2 temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //判断是否到链表最后</span><br><span class="line">            <span class="keyword">if</span> (temp == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line"></span><br><span class="line">            //将temp后移，否则死循环</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//英雄类</span><br><span class="line">class HeroNode2 &#123;</span><br><span class="line">    public int no;</span><br><span class="line">    public String name;</span><br><span class="line">    public String nickname;</span><br><span class="line">    public HeroNode2 pre;//前一个结点</span><br><span class="line">    public HeroNode2 next;//后一个结点</span><br><span class="line"></span><br><span class="line">    //构造器</span><br><span class="line">    public HeroNode2(int no, String name, String nickname) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;HeroNode2&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;</span><span class="string">&#x27; +</span></span><br><span class="line"><span class="string">                &quot;, nickname=&#x27;</span><span class="string">&quot; + nickname + &#x27;\&#x27;&#x27; +</span></span><br><span class="line"><span class="string">                &#x27;&#125;&#x27;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>以上内容为博主总结，用于日后复习与巩固，如果转载请注明来源，谢谢。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之稀疏数组</title>
    <url>/2021/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>当一个数组中大部分元素为0，或者为同一个值，可以使用稀疏数组来保存该数组。</p>
<h4 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h4><p>1.记录数组一共有几行几列，有多少个不同的值。<br>2.把具有不同的元素的行列及值记录在一个小规模数组中（稀疏数组），从而缩小程序规模。</p>
<span id="more"></span>

<h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p>原始二维数组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">0  0  0  1  0              </span><br><span class="line">0  1  0  0  2</span><br><span class="line">0  0  3  0  0         </span><br><span class="line">2  0  5  0  0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>转换为：<br>        稀疏数组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">     行  列   值</span><br><span class="line">    row  col  val</span><br><span class="line">[0]  4    5    6 总（原始二维数组有几行几列，几个不同值） </span><br><span class="line">[1]  0    3    1</span><br><span class="line">[2]  1    1    1</span><br><span class="line">[3]  1    4    2</span><br><span class="line">[4]  2    2    3</span><br><span class="line">[5]  3    0    2</span><br><span class="line">[6]  3    2    5</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>行数不确定，列数始终为3</p>
<h4 id="二维数组转稀疏数组思路"><a href="#二维数组转稀疏数组思路" class="headerlink" title="二维数组转稀疏数组思路"></a>二维数组转稀疏数组思路</h4><p>1.遍历原始二维数组，得到有效数据个数(sum)。<br>2.根据sum的值创建稀疏数组int[][] sparseArr=new int[sum+1][3];<br>3.将二维数组有效数据存入到稀疏数组中。（[0]行为总数）</p>
<h4 id="稀疏数组转二维数组思路"><a href="#稀疏数组转二维数组思路" class="headerlink" title="稀疏数组转二维数组思路"></a>稀疏数组转二维数组思路</h4><p>1.先读取稀疏数组第一行，根据第一行数据，创建原始二维数组(chessArr2)。<br>2.再读取稀疏数组后几行的数据，并赋值给原始的二维数组(chessArr2)。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.sparsearray;</span><br><span class="line"></span><br><span class="line">public class SparseArray &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //创建原始二维数组11*11（棋盘大小）</span><br><span class="line">        //0表示没有棋子，1表示黑子，2表示蓝子</span><br><span class="line">        int[][] chessArr1 = new int[11][11];</span><br><span class="line">        chessArr1[1][2] = 1;</span><br><span class="line">        chessArr1[2][3] = 2;</span><br><span class="line"></span><br><span class="line">        //输出原始二维数组</span><br><span class="line">        System.out.println(<span class="string">&quot;原始数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (int[] row : chessArr1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (int data : row) &#123;</span><br><span class="line">                System.out.print(data + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //将二维数组转成稀疏数组</span><br><span class="line">        //遍历二维数组，得到非0元素的个数</span><br><span class="line">        int sum = 0;</span><br><span class="line">        <span class="keyword">for</span> (int[] row : chessArr1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (int data : row) &#123;</span><br><span class="line">                <span class="keyword">if</span> (data != 0) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //定义一个稀疏数组</span><br><span class="line">        int[][] sparseArr = new int[sum + 1][3];</span><br><span class="line">        sparseArr[0][0] = 11;</span><br><span class="line">        sparseArr[0][1] = 11;</span><br><span class="line">        sparseArr[0][2] = sum;</span><br><span class="line"></span><br><span class="line">        //普通<span class="keyword">for</span>循环遍历二维数组，得到下标，用于储存到稀疏数组中</span><br><span class="line">        int count = 0;    //用于记录第几个非0数据以及对应的稀疏数组的行索引</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; chessArr1.length; i++)</span><br><span class="line">            <span class="keyword">for</span> (int j = 0; j &lt; chessArr1.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr1[i][j] != 0) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArr[count][0] = i;</span><br><span class="line">                    sparseArr[count][1] = j;</span><br><span class="line">                    sparseArr[count][2] = chessArr1[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        //遍历输出稀疏数组</span><br><span class="line">        System.out.println(<span class="string">&quot;稀疏数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (int[] row : sparseArr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (int data : row) &#123;</span><br><span class="line">                System.out.print(data + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //稀疏数组还原为二维数组</span><br><span class="line">        //读取稀疏数组第一行，创建二维数组</span><br><span class="line">        int [][]chessArr2=new int[sparseArr[0][0]][sparseArr[0][1]];</span><br><span class="line"></span><br><span class="line">        //读取稀疏数组的后几行（第二行开始），并赋值给二维数组</span><br><span class="line">        <span class="keyword">for</span> (int i=1;i&lt;sparseArr.length;i++) &#123;</span><br><span class="line">            chessArr2[sparseArr[i][0]][sparseArr[i][1]]=sparseArr[i][2];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //输出chessArr2数组</span><br><span class="line">        System.out.println(<span class="string">&quot;恢复后chessArr数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (int[] row : chessArr2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (int data : row) &#123;</span><br><span class="line">                System.out.print(data + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><font color="#dd0000">（注：二维数组增强for循环遍历第一次得到的是类型为int[]的行，类型为int[]的行再次增强for循环得到二维数组的每一个值。）</font><br /></p>
<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>以上内容为博主总结，用于日后复习与巩固，如果转载请注明来源，谢谢。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之队列(1)</title>
    <url>/2021/09/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97(1)/</url>
    <content><![CDATA[<h3 id="队列（数组模拟实现）"><a href="#队列（数组模拟实现）" class="headerlink" title="队列（数组模拟实现）"></a>队列（数组模拟实现）</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1.队列是个有序列表，可以用数组或链表来实现<br>2.遵循先入先出原则，即先存入队列的数据先取出，后存入队列的数据后取出</p>
<span id="more"></span>

<h4 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h4><p>1.队列的输出、输入分别从前后端来处理，需要两个变量front和rear分别记录队列前后端的索引，front会随着数据的输出而改变，rear会随着数据的输入而改变。还需要一个变量maxSize来记录队列的最大容量。<br><font color="#dd0000"><br>front = -1，进行初始化，指向队列头的前一个位置<br>rear = -1， 指向队列尾部的数据（就是队列最后一个数据）<br></font><br /></p>
<h4 id="队列数据的添加操作"><a href="#队列数据的添加操作" class="headerlink" title="队列数据的添加操作"></a>队列数据的添加操作</h4><p>1.将数据存入队列时称为“addQueue”，“addQueue”的处理需要两个步骤：<br>1)先判断队列是否为满，若尾指针rear小于队列的最大索引maxsize-1，则将数据存入rear所指的数组元素中，否则无法存入数据。<font color="#dd0000">（rear==maxSize-1时，队列满，即无法添加数据）</font><br /><br>2)将尾指针(rear)往后移：rear+1，将要添加的数赋值给索引为rear+1的数组。<font color="#dd0000">（注：当front==rear时，队列为空）</font><br /></p>
<h4 id="队列数据的取出操作"><a href="#队列数据的取出操作" class="headerlink" title="队列数据的取出操作"></a>队列数据的取出操作</h4><p>1.从队列中取出数据时称为“getQueue”，“getQueue”的处理需要两个步骤：<br>1)判断队列是否为空。<br>2)将front往后移，取出的数为索引为rear+1的元素。</p>
<h4 id="已知问题及优化"><a href="#已知问题及优化" class="headerlink" title="已知问题及优化"></a>已知问题及优化</h4><p>1.问题：数组使用一次就不能用了，没有达到复用的效果。<br>2.优化：将这个数组使用算法，改进成一个环形的队列。（取模:%）<font color="#dd0000">（见数据结构之队列(2)）</font><br /></p>
<h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.queue;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class ArrayQueueDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建队列</span><br><span class="line">        ArrayQueue arrayQueue = new ArrayQueue(3);</span><br><span class="line">        //接收用户输入</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        boolean loop = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s(show)：显示队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(exit)：退出队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a(add)：添加数据到队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g(get)：从队列取出数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(head)：查看队列头的数据&quot;</span>);</span><br><span class="line">            char key = sc.next().charAt(0);</span><br><span class="line">            switch (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    arrayQueue.showQueue();</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                    sc.close();</span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    System.out.println(<span class="string">&quot;程序退出&quot;</span>);</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入一个数：&quot;</span>);</span><br><span class="line">                    Scanner sc1 = new Scanner(System.in);</span><br><span class="line">                    int value1 = sc.nextInt();</span><br><span class="line">                    arrayQueue.addQueue(value1);</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res = arrayQueue.getQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;取出的数据是%d\n&quot;</span>, res);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res = arrayQueue.headQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;队列头数据是%d\n&quot;</span>, res);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//编写一个ArrayQueue的类</span><br><span class="line">class ArrayQueue &#123;</span><br><span class="line">    private int maxSize;    //表示数组最大容量</span><br><span class="line">    private int front;  //队列头</span><br><span class="line">    private int rear;   //队列尾</span><br><span class="line">    private int[] arr;  //该数组用于存放数据，模拟队列</span><br><span class="line"></span><br><span class="line">    //创建队列的构造器</span><br><span class="line">    public ArrayQueue(int arrMaxSize) &#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = new int[maxSize];</span><br><span class="line">        front = -1;   //进行初始化，指向队列头的前一个位置</span><br><span class="line">        rear = -1;    //指向队列尾部的数据（就是队列最后一个数据）</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断队列是否满</span><br><span class="line">    public boolean <span class="function"><span class="title">isFull</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> maxSize - 1 == rear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断队列是否为空</span><br><span class="line">    public boolean <span class="function"><span class="title">isEmpty</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> front == rear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //添加数据到队列</span><br><span class="line">    public void addQueue(int n) &#123;</span><br><span class="line">        //判断队列是否满</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列满了，无法添加数据！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        //添加数据</span><br><span class="line">        rear++;</span><br><span class="line">        arr[rear] = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取队列的数据（出队列）</span><br><span class="line">    public int <span class="function"><span class="title">getQueue</span></span>() &#123;</span><br><span class="line">        //判断队列是否为空</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            //如果为空，通过抛出异常来处理</span><br><span class="line">            throw new RuntimeException(<span class="string">&quot;队列为空，无法获取数据！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        front++;</span><br><span class="line">        <span class="built_in">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示队列的所有数据</span><br><span class="line">    public void <span class="function"><span class="title">showQueue</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列为空，没有数据！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (int a = 0; a &lt; arr.length; a++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;arr[&quot;</span> + a + <span class="string">&quot;]=&quot;</span> + arr[a] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示队列的头数据（不是取出数据，仅仅是显示）</span><br><span class="line">    public int <span class="function"><span class="title">headQueue</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(<span class="string">&quot;队列为空，没有头数据！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> arr[front + 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>以上内容为博主总结，用于日后复习与巩固，如果转载请注明来源，谢谢。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>第一次拥有了属于自己的博客</title>
    <url>/2021/07/29/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8B%A5%E6%9C%89%E4%BA%86%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>欢迎来到mana的小窝，这是我的第一个博客！很久以前就想建立一个自己的博客，当时因为各种原因未能实现（主要还是技术菜），昨天突然心血来潮，再次想要创建博客，于是在网络上看到一篇文章：用<a href="https://zhuanlan.zhihu.com/p/102592286">Github+hexo</a>创建博客，说到Github，很久以前注册过账号，但也仅仅是停留在注册这里,并没有真正用过，我想，以后应该会经常使用的。所以就照着答主的教程开始搭建，期间因为种种原因，遇到很多问题，各种百度查资料，最终还是完成了。过后我会在他的基础上完善修正一下搭建博客的教程。</p>
<h2 id="创建此博客的想法"><a href="#创建此博客的想法" class="headerlink" title="创建此博客的想法"></a>创建此博客的想法</h2><p>因为本人是软件工程专业的，写下此篇博客的时间为大一下的暑假。因为在此之前自学完了javase，html、css、javascript的基础语法，当时也没有将遇到的问题记录下来，也是有点小遗憾。所以博客仅用来分享记录我学习路上遇到的问题和心情等等。</p>
]]></content>
      <categories>
        <category>记录心情</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之队列(2)环形队列</title>
    <url>/2021/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97-2-%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="数组模拟环形队列"><a href="#数组模拟环形队列" class="headerlink" title="数组模拟环形队列"></a>数组模拟环形队列</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p> 用于解决数组模拟队列不能复用的问题。</p>
<span id="more"></span>

<h4 id="思路及图解"><a href="#思路及图解" class="headerlink" title="思路及图解"></a>思路及图解</h4><p>1.front的含义做一个调整：front指向队列的第一个元素。<font color="#dd0000">（原来front指向队列第一个元素的前一个位置）</font><br />也就是说，arr[front]为队列的第一个元素。<font color="#dd0000">（front的初始值为0）</font><br /><br>2.rear的含义也做一个调整：rear指向队列的最后一个元素的后一个位置。<font color="#dd0000">（原来rear指向队列最后一个元素的位置，rear的初始值也为0）</font><br /><br>3.当队列满时，条件为(rear+1)%maxSize==front</p>
<h4 id="图解（很重要！）"><a href="#图解（很重要！）" class="headerlink" title="图解（很重要！）"></a>图解<font color="#dd0000">（很重要！）</font><br /></h4><p><img src="https://i.loli.net/2021/09/19/FBwzUEtshNaLrDA.png" alt="环形队列.png"></p>
<p>(1)数组最大容量为：maxSize=4<br>(2)实际容量为：maxSize-1=3<font color="#dd0000">（因为要预留一个空间作为约定，用于判断队列是否为满，因为如果不留空，那么判断队列空和队列满的条件就都为：rear==front，无法判断）</font><br /><br>(3)第一个元素索引为：front=0<font color="#dd0000">（没有做取出操作的时候）</font><br /><br>(4)索引为3的位置空出来了。<br>(5)当索引为0、1、2的位置都存有元素后，认为该队列为满，此时：<br>1)maxSize=4<br>2)front=0<br>3)rear=3<br>即满足(rear+1)%maxSize==0<font color="#dd0000"> rear、front均代表索引。</font><br /></p>
<p>4.当队列为空时，条件为rear==front<br>5.我们这样分析，队列中有效的数据的个数为：(rear+maxSize-front)%maxSize<br>6.我们就可以在原来的队列上修改得到一个环形队列。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.queue;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class CircleArrayQueueDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建一个环形队列</span><br><span class="line">        CircleArray circleArray = new CircleArray(4);</span><br><span class="line">        //接收用户输入</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        boolean loop = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s(show)：显示队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(exit)：退出队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a(add)：添加数据到队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g(get)：从队列取出数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(head)：查看队列头的数据&quot;</span>);</span><br><span class="line">            char key = sc.next().charAt(0);</span><br><span class="line">            switch (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    circleArray.showQueue();</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                    sc.close();</span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    System.out.println(<span class="string">&quot;程序退出&quot;</span>);</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入一个数：&quot;</span>);</span><br><span class="line">                    Scanner sc1 = new Scanner(System.in);</span><br><span class="line">                    int value1 = sc.nextInt();</span><br><span class="line">                    circleArray.addQueue(value1);</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res = circleArray.getQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;取出的数据是%d\n&quot;</span>, res);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res = circleArray.headQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;队列头数据是%d\n&quot;</span>, res);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CircleArray &#123;</span><br><span class="line">    private int maxSize;    //表示数组最大容量</span><br><span class="line">    private int front;  //队列头 front的含义做一个改变：front指向队列的第一个元素，arr[front]就是队列的第一个元素</span><br><span class="line">    // front的初始值=0</span><br><span class="line">    private int rear;   //队列尾 rear的含义做一个改变：rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为约定</span><br><span class="line">    //rear的初始值=0</span><br><span class="line">    private int[] arr;  //该数组用于存放数据，模拟队列</span><br><span class="line"></span><br><span class="line">    public CircleArray(int arrMaxSize) &#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = new int[maxSize];</span><br><span class="line">        front = 0;</span><br><span class="line">        rear = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断队列是否为满</span><br><span class="line">    public boolean <span class="function"><span class="title">isFull</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> (rear + 1) % maxSize == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断队列是否为空</span><br><span class="line">    public boolean <span class="function"><span class="title">isEmpty</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //添加数据到队列</span><br><span class="line">    public void addQueue(int n) &#123;</span><br><span class="line">        //判断队列是否满</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列满了，无法添加数据！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //添加数据</span><br><span class="line">        arr[rear] = n;</span><br><span class="line">        //将rear后移，这里必须考虑取模%</span><br><span class="line">        rear = (rear + 1) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取队列的数据（出队列）</span><br><span class="line">    public int <span class="function"><span class="title">getQueue</span></span>() &#123;</span><br><span class="line">        //判断队列是否为空</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            //如果为空，通过抛出异常来处理</span><br><span class="line">            throw new RuntimeException(<span class="string">&quot;队列为空，无法获取数据！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        //先用临时变量保存front的值，如果不这么做，会导致<span class="built_in">return</span>之后，无法再修改front的值</span><br><span class="line">        int temp = arr[front];</span><br><span class="line">        front = (front + 1) % (maxSize);</span><br><span class="line">        <span class="built_in">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示队列的所有数据</span><br><span class="line">    public void <span class="function"><span class="title">showQueue</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列为空，没有数据！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        //从front开始遍历，遍历的元素个数为：(rear+maxSize-front)%maxSize</span><br><span class="line">        <span class="keyword">for</span> (int a = front; a &lt; front + size(); a++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;arr[&quot;</span> + a % maxSize + <span class="string">&quot;]=&quot;</span> + arr[a % maxSize] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //System.out.println(<span class="string">&quot;arr[&quot;</span> + a % maxSize + <span class="string">&quot;]=&quot;</span> + arr[a % maxSize] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    //System.out.printf(<span class="string">&quot;arr[%d]=%d\n&quot;</span>, a % maxSize, arr[a % maxSize])</span><br><span class="line"></span><br><span class="line">    //求出当前队列有效数据个数</span><br><span class="line">    public int <span class="function"><span class="title">size</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> (rear + maxSize - front) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示队列的头数据（不是取出数据，仅仅是显示）</span><br><span class="line">    public int <span class="function"><span class="title">headQueue</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(<span class="string">&quot;队列为空，没有头数据！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><font color="#dd0000"></font><br /></p>
<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>以上内容为博主总结，用于日后复习与巩固，如果转载请注明来源，谢谢。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>解决hexo部署之后需要重新修改域名的问题</title>
    <url>/2021/08/16/%E8%A7%A3%E5%86%B3hexo%E9%83%A8%E7%BD%B2%E4%B9%8B%E5%90%8E%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E4%BF%AE%E6%94%B9%E5%9F%9F%E5%90%8D%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="教程开始"><a href="#教程开始" class="headerlink" title="教程开始"></a>教程开始</h3><p>1.打开博客的source目录，创建CNAME文件，在CNAME中写上自己的域名。<br>2.在hexo博客目录下，右键选择Git Bash Here,输入以下代码并回车：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>3.over!</p>
]]></content>
      <categories>
        <category>hexo博客操作相关</category>
      </categories>
  </entry>
  <entry>
    <title>算法之约瑟夫问题</title>
    <url>/2021/10/24/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><h5 id="什么是约瑟夫问题"><a href="#什么是约瑟夫问题" class="headerlink" title="什么是约瑟夫问题"></a>什么是约瑟夫问题</h5><p>设编号为1,2···n的n个人围坐在一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m的那个人出列，他的下一位又从1开始报数，数到m的那个人又出列，以此类推，直到所有人都出列为止，由此产生一个出队编号的数列。</p>
<span id="more"></span>

<h4 id="单向环形链表"><a href="#单向环形链表" class="headerlink" title="单向环形链表"></a>单向环形链表</h4><h5 id="构建单向环形链表"><a href="#构建单向环形链表" class="headerlink" title="构建单向环形链表"></a>构建单向环形链表</h5><p>因为解决约瑟夫问题需要用到单向环形链表，所以给出构建环形链表思路。<br>1)创建第一个结点，让first指向该结点，并形成环形。<br>2)后面每创建一个新的结点，就把该结点加入到已有的环形链表中。<br>3)具体参考代码实现</p>
<h5 id="遍历环形链表"><a href="#遍历环形链表" class="headerlink" title="遍历环形链表"></a>遍历环形链表</h5><p>1)让辅助变量指向first结点。<br>2)while循环遍历，辅助变量.next==first结束。</p>
<h4 id="解决约瑟夫问题"><a href="#解决约瑟夫问题" class="headerlink" title="解决约瑟夫问题"></a>解决约瑟夫问题</h4><p><font color="#dd0000">（注:因为结点只有一个编号属性，所以代码中建立单向循环链表的方式为for循环）</font><br /><br>1.创建一个辅助变量(helper)，事先应该指向单向环形链表的最后这个结点。(在first变量的前一个)<br>2.先让first和helper移动k-1次。<br>3.当小孩(结点)报数时，再让first和helper变量（指针）同时移动m-1次。<br>4.此时可以将first指向的小孩结点出圈。（输出first）<br>1)first=first.next<br>2)helper.next=first<br>原来first的结点就相当于被删除（出圈）了（没有任何引用被回收）</p>
<p><img src="https://i.loli.net/2021/10/24/4KZBMQX1CJFE5hd.png" alt="单向环形链表.PNG"></p>
<p>单向环形链表图</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>包含for循环创建单向循环链表和解决约瑟夫问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.linkedlist;</span><br><span class="line"></span><br><span class="line">public class Joseph &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        /*</span><br><span class="line">        关于约瑟夫问题</span><br><span class="line">        此处的n个人即为代码里的nums</span><br><span class="line">        设编号为1,2···n的n个人围坐在一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m的那个人出列</span><br><span class="line">        他的下一位又从1开始报数，数到m的那个人又出列，以此类推，直到所有人都出列为止</span><br><span class="line">        由此产生一个出队编号的数列</span><br><span class="line">        当nums（n）=5，k=1，m=2时，</span><br><span class="line">        出队列的顺序为:</span><br><span class="line">           2,4,1,5,3</span><br><span class="line">        */</span><br><span class="line">        //nums为有几个人</span><br><span class="line">        //k为从第几个开始数</span><br><span class="line">        //m为数几下</span><br><span class="line">        int nums = 5;</span><br><span class="line">        int k = 1;</span><br><span class="line">        int m = 2;</span><br><span class="line">        CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();</span><br><span class="line">        circleSingleLinkedList.newBoy(nums);</span><br><span class="line">        //遍历环形链表</span><br><span class="line">        //circleSingleLinkedList.show();</span><br><span class="line">        //测试Joseph方法解决约瑟夫问题</span><br><span class="line">        circleSingleLinkedList.Joseph(k, m);</span><br><span class="line">        //间隔线</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class CircleSingleLinkedList &#123;</span><br><span class="line">    //创建一个first结点</span><br><span class="line">    private Boy first = null;</span><br><span class="line"></span><br><span class="line">    public void newBoy(int nums) &#123;</span><br><span class="line">        //nums代表要创建几个Boy结点</span><br><span class="line">        //先对nubs做简单的数据校验</span><br><span class="line">        <span class="keyword">if</span> (nums &lt; 1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;nums的值不合法！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Boy curBoy = null;//辅助变量，帮助创建环形链表</span><br><span class="line">        //使用<span class="keyword">for</span>循环创建单向循环链表</span><br><span class="line">        <span class="keyword">for</span> (int i = 1; i &lt;= nums; i++) &#123;</span><br><span class="line">            Boy boy = new Boy(i);</span><br><span class="line">            //如果是第一个小孩，让first指向boy</span><br><span class="line">            <span class="keyword">if</span> (i == 1) &#123;</span><br><span class="line">                first = boy;</span><br><span class="line">                first.setNext(first);//构成环，只有一个boy结点</span><br><span class="line">                curBoy = first;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curBoy.setNext(boy);</span><br><span class="line">                boy.setNext(first);</span><br><span class="line">                curBoy = curBoy.getNext();//也可以写成curBoy = boy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        //判断是否为空</span><br><span class="line">        <span class="keyword">if</span> (first == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Boy temp = first;</span><br><span class="line">        <span class="keyword">while</span> (temp.getNext() != first) &#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp = temp.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        //单独打印以下最后的结点，（因为是先判断temp.getNext() != first，后打印，所以会落下最后一个结点）</span><br><span class="line">        System.out.println(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param k k为从第几个开始数</span><br><span class="line">     * @param m m为数几下</span><br><span class="line">     */</span><br><span class="line">    public void Joseph(int k, int m) &#123;</span><br><span class="line">        Boy helper = first;</span><br><span class="line">        //将helper指向最后结点</span><br><span class="line">        <span class="keyword">while</span> (helper.getNext() != first) &#123;</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        //先将first移动到k的位置，将helper移动到新的末尾结点，也就是first的前一个结点（因为是环形链表）</span><br><span class="line">        <span class="keyword">for</span> (int i = 1; i &lt; k; i++) &#123;</span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        //当链表只剩一个人的时候，循环结束</span><br><span class="line">        <span class="keyword">while</span> (helper != first) &#123;</span><br><span class="line">            //再让first和helper向后移动m-1次</span><br><span class="line">            <span class="keyword">for</span> (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">                first = first.getNext();</span><br><span class="line">                helper = helper.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            //然后让first指向的结点出圈（进行删除操作）</span><br><span class="line">            System.out.println(first);</span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper.setNext(first);</span><br><span class="line">        &#125;</span><br><span class="line">        //当结束<span class="keyword">while</span>循环时，圈中还有一个结点，将它输出</span><br><span class="line">        System.out.println(first);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //创建一个Boy类，表示一个结点</span><br><span class="line">    class Boy &#123;</span><br><span class="line">        private int no;//编号</span><br><span class="line">        private Boy next;//指向下一个结点</span><br><span class="line"></span><br><span class="line">        //带参构造方法</span><br><span class="line">        public Boy(int no) &#123;</span><br><span class="line">            this.no = no;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int <span class="function"><span class="title">getNo</span></span>() &#123;</span><br><span class="line">            <span class="built_in">return</span> no;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setNo(int no) &#123;</span><br><span class="line">            this.no = no;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Boy <span class="function"><span class="title">getNext</span></span>() &#123;</span><br><span class="line">            <span class="built_in">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setNext(Boy next) &#123;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="string">&quot;Boy&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之栈（数组模拟）</title>
    <url>/2021/10/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88%EF%BC%88%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%EF%BC%89/</url>
    <content><![CDATA[<h3 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈(stack)"></a>栈(stack)</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1)栈是一个先入后出的有序列表（FILO-First In Last Out）<br>2)栈是一个限制性表，表中元素的插入和删除只能在线性表的同一端进行，是一种特殊的线性表，允许插入和删除的一端为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)<br>3)根据栈的定义可知，最先放入栈的元素在栈底，最后放入栈的元素在栈顶，而删除元素正好相反，最后放入的元素最先删除，最先放入的元素最后删除。</p>
<span id="more"></span>

<h4 id="栈的应用场景"><a href="#栈的应用场景" class="headerlink" title="栈的应用场景"></a>栈的应用场景</h4><p>1.子程序的调用<br>2.处理递归调用<br>3.表达式的转[中缀表达式转后缀表达式]与求值（实际解决）<br>4.二叉树的遍历<br>5.图形的深度优先(depth-first)搜索法</p>
<h4 id="数组模拟栈"><a href="#数组模拟栈" class="headerlink" title="数组模拟栈"></a>数组模拟栈</h4><p>1.使用数组来模拟栈<br>2.定义一个Top表示栈顶，初始化为-1<br>3.入栈(push)操作：当有数据加入到栈中时<br>top++;<br>stack[top]=data;<br>4.出栈(pop)操作：<br>int fata=stack[top];<br>top–;<br>raturn data;</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.stack;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class ArrayStackDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayStack arrayStack = new ArrayStack(5);</span><br><span class="line">        boolean loop = <span class="literal">true</span>;//控制菜单循环</span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;show：表示显示栈&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;pop：表示出栈&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;push：表示入栈&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;exit：表示退出栈&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入你的选择：&quot;</span>);</span><br><span class="line">            Scanner scanner = new Scanner(System.in);</span><br><span class="line">            String key = scanner.next();</span><br><span class="line">            switch (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;show&quot;</span>:</span><br><span class="line">                    arrayStack.show();</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;pop&quot;</span>:</span><br><span class="line">                    arrayStack.pop();</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;push&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入想添加的数据：&quot;</span>);</span><br><span class="line">                    Scanner sc = new Scanner(System.in);</span><br><span class="line">                    arrayStack.push(sc.nextInt());</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    System.out.println(<span class="string">&quot;程序退出！&quot;</span>);</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//定义一个类，表示栈</span><br><span class="line">class ArrayStack &#123;</span><br><span class="line">    private int maxSize;//栈的大小</span><br><span class="line">    private int[] stack;//数组存放栈的数据</span><br><span class="line">    private int top = -1;//栈顶，初始化为-1</span><br><span class="line"></span><br><span class="line">    //构造方法</span><br><span class="line">    public ArrayStack(int maxSize) &#123;</span><br><span class="line">        this.maxSize = maxSize;</span><br><span class="line">        stack = new int[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断栈满</span><br><span class="line">    public boolean <span class="function"><span class="title">isFull</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> top == maxSize - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断栈空</span><br><span class="line">    public boolean <span class="function"><span class="title">isEmpty</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> top == -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //入栈</span><br><span class="line">    public void push(int data) &#123;</span><br><span class="line">        //判断栈是否为满</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈已满，无法执行进栈操作！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = data;</span><br><span class="line">        System.out.println(data + <span class="string">&quot;已被添加到栈顶！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //出栈</span><br><span class="line">    public int <span class="function"><span class="title">pop</span></span>() &#123;</span><br><span class="line">        //先判断栈是否为空</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(<span class="string">&quot;栈空，无法执行出栈操作！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        int data = stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        System.out.println(<span class="string">&quot;栈顶数据&quot;</span> + data + <span class="string">&quot;已被删除！&quot;</span>);</span><br><span class="line">        <span class="built_in">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示栈的内容（遍历）</span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈为空！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (int i = top; i &gt;= 0; i--) &#123;</span><br><span class="line">            System.out.println(stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;ArrayStack&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;stack=&quot;</span> + Arrays.toString(stack) +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>以上内容为博主总结，用于日后复习与巩固，如果转载请注明来源，谢谢</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之栈（链式）</title>
    <url>/2021/10/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88%EF%BC%88%E9%93%BE%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<h3 id="栈（链式）"><a href="#栈（链式）" class="headerlink" title="栈（链式）"></a>栈（链式）</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1.栈的链式实现<br>2.入栈(push)<br>3.出栈(pop)<br>4.具体请看代码实现</p>
<span id="more"></span>

<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.stack;</span><br><span class="line"></span><br><span class="line">public class LinkedStack &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Node node1 = new Node(1);</span><br><span class="line">        Node node2 = new Node(2);</span><br><span class="line">        Node node3 = new Node(3);</span><br><span class="line">        Node node4 = new Node(4);</span><br><span class="line">        Node node5 = new Node(5);</span><br><span class="line">        Node node6 = new Node(5);</span><br><span class="line">        LinkedList linkedList = new LinkedList();</span><br><span class="line">        linkedList.push(node1);</span><br><span class="line">        linkedList.push(node2);</span><br><span class="line">        linkedList.push(node3);</span><br><span class="line">        linkedList.push(node4);</span><br><span class="line">        linkedList.push(node5);</span><br><span class="line">        //测试添加相同data</span><br><span class="line">        linkedList.push(node6);</span><br><span class="line">        linkedList.pop();</span><br><span class="line">        linkedList.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Node &#123;</span><br><span class="line">    private int data;</span><br><span class="line">    private Node next;</span><br><span class="line"></span><br><span class="line">    public Node(int data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int <span class="function"><span class="title">getData</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(int data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node <span class="function"><span class="title">getNext</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNext(Node next) &#123;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class LinkedList &#123;</span><br><span class="line">    Node top = null;</span><br><span class="line"></span><br><span class="line">    //判断是否为空</span><br><span class="line">    public boolean <span class="function"><span class="title">isEmpty</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> top == null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //入栈</span><br><span class="line">    public void push(Node node) &#123;</span><br><span class="line">        node.setNext(top);</span><br><span class="line">        top = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //出栈</span><br><span class="line">    public int <span class="function"><span class="title">pop</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(<span class="string">&quot;栈为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        int data = top.getData();</span><br><span class="line">        System.out.println(<span class="string">&quot;出栈的数据为：&quot;</span> + data);</span><br><span class="line">        top = top.getNext();</span><br><span class="line">        <span class="built_in">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历栈</span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(<span class="string">&quot;栈为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp = top;</span><br><span class="line">        <span class="keyword">while</span> (temp != null) &#123;</span><br><span class="line">            System.out.println(temp.getData());</span><br><span class="line">            temp = temp.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        //剩一个结点单独输出</span><br><span class="line">        //System.out.println(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>以上内容为博主总结，用于日后复习与巩固，如果转载请注明来源，谢谢</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
</search>
