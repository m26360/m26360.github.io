<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mana的博客</title>
  
  
  <link href="https://www.m26360.com/atom.xml" rel="self"/>
  
  <link href="https://www.m26360.com/"/>
  <updated>2021-11-03T11:18:21.513Z</updated>
  <id>https://www.m26360.com/</id>
  
  <author>
    <name>mana</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>中缀表达式转后缀表达式</title>
    <link href="https://www.m26360.com/2021/11/03/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://www.m26360.com/2021/11/03/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2021-11-03T11:02:36.000Z</published>
    <updated>2021-11-03T11:18:21.513Z</updated>
    
    <content type="html"><![CDATA[<h3 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h3><h4 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h4><p>1.初始化两个栈：运算符栈s1和储存中间结果的栈s2<br>2.从左至右扫描中缀表达式<br>3.遇到数字时，将其压入s2<br>4.遇到运算符时，比较其与s1栈顶运算符的优先级<br>(1)如果s1为空，或栈顶元素为左括号“)”，则直接将此运算符入s1栈<br>(2)否则，若运算符优先级比栈顶运算符优先级高，也将运算符压入s1栈<br>(3)若运算符优先级比栈顶运算符优先级低，将s1栈顶的运算符弹出，并压入到s2中，再次转到4.1)步，与s1中新的栈顶运算符相比较<br>5.遇到括号时：<br>(1)如果是左括号“(”，则直接压入s1<br>(2)如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃<br>6.重复步骤2-5，直到扫描完表达式<br>7.将s1中剩余的运算符依次弹出并压入s2栈<br>8.依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式</p><h4 id="表达式举例"><a href="#表达式举例" class="headerlink" title="表达式举例"></a>表达式举例</h4><p>中缀表达式：1 + ( ( 2 + 3 ) * 4 ) - 5<br>转换后的后缀表达式：1 2 3 + 4 * + 5 -</p><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="https://i.loli.net/2021/11/03/VthvO5jc3oexJdH.png" alt="中缀转后缀.PNG"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.stack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class ChangePolandNotation &#123;</span><br><span class="line">    //将一个中缀表达式转换为后缀表达式</span><br><span class="line">    //1.  1+((2+3)*4)-5  =&gt;   1 2 3 + 4 * + 5 -</span><br><span class="line">    //2.  直接对str进行操作不方便，先将1+((2+3)*4)-5 转换为中缀表达式对应的List</span><br><span class="line">    //后缀表达式（逆波兰表达式为） (3+4)*5-6    =&gt;      3 4 + 5 * 6 -</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //中缀表达式</span><br><span class="line">        String expression = <span class="string">&quot;1 + ( ( 2 + 3 ) * 4 ) - 5 &quot;</span>;</span><br><span class="line">        ChangePolandNotation changePolandNotation = new ChangePolandNotation();</span><br><span class="line">        changePolandNotation.cal(expression);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void cal(String expression) &#123;</span><br><span class="line">        Stack&lt;String&gt; s1 = new Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;String&gt; s2 = new Stack&lt;&gt;();</span><br><span class="line">        //将expression用空格分割成String数组</span><br><span class="line">        String[] split = expression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        //增强<span class="keyword">for</span>循环遍历String数组</span><br><span class="line">        <span class="keyword">for</span> (String ele : split) &#123;</span><br><span class="line">            //如果是数字将其压入s2栈</span><br><span class="line">            <span class="keyword">if</span> (ele.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123;</span><br><span class="line">                s2.push(ele);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ele.equals(<span class="string">&quot;(&quot;</span>) || ele.equals(<span class="string">&quot;)&quot;</span>)) &#123;//如果是左右小括号</span><br><span class="line">                <span class="keyword">if</span> (ele.equals(<span class="string">&quot;(&quot;</span>)) &#123;//如果是左括号</span><br><span class="line">                    s1.push(ele);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;//如果是右括号</span><br><span class="line">                    <span class="keyword">while</span> (!s1.peek().equals(<span class="string">&quot;(&quot;</span>)) &#123;//如果s1栈顶不是左括号</span><br><span class="line">                        String temp = s1.peek();//弹出s1栈顶的运算符，并压入s2</span><br><span class="line">                        s2.push(temp);</span><br><span class="line">                        s1.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    //直到遇到左括号，将其丢弃</span><br><span class="line">                    s1.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;//如果遇到运算符</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s1.empty() || s1.peek().equals(<span class="string">&quot;(&quot;</span>)) &#123;//如果s1为空或栈顶为左括号</span><br><span class="line">                        s1.push(ele);</span><br><span class="line">                        <span class="built_in">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;//若不为空，判断操作符优先级</span><br><span class="line">                        <span class="keyword">if</span> (priority(ele) &gt; priority(s1.peek())) &#123;//如果ele优先级比栈顶操作符优先级高</span><br><span class="line">                            s1.push(ele);</span><br><span class="line">                            <span class="built_in">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;//如果ele优先级比栈顶操作符优先级低，弹出s1栈顶的运算符，并压入s2</span><br><span class="line">                            String temp = s1.peek();</span><br><span class="line">                            s2.push(temp);</span><br><span class="line">                            s1.pop();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //将s1中剩余的运算符依次弹出并压入s2</span><br><span class="line">        <span class="keyword">while</span> (!s1.empty()) &#123;</span><br><span class="line">            String temp = s1.peek();</span><br><span class="line">            s2.push(temp);</span><br><span class="line">            s1.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //依次弹出s2中的元素，其逆序即为后缀表达式</span><br><span class="line">        //做法是将s2栈中的元素压入s1，s1即为逆序的s2</span><br><span class="line">        <span class="keyword">while</span> (!s2.empty()) &#123;</span><br><span class="line">            String temp = s2.peek();</span><br><span class="line">            s1.push(temp);</span><br><span class="line">            s2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历s1栈</span><br><span class="line">        <span class="keyword">while</span> (!s1.empty()) &#123;</span><br><span class="line">            System.out.println(s1.peek());</span><br><span class="line">            s1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int priority(String oper) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oper.equals(<span class="string">&quot;*&quot;</span>) || oper.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">return</span> 1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oper.equals(<span class="string">&quot;+&quot;</span>) || oper.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">return</span> 0;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> -1;//只能运算加减乘除，否则返回-1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;中缀表达式转后缀表达式&quot;&gt;&lt;a href=&quot;#中缀表达式转后缀表达式&quot; class=&quot;headerlink&quot; title=&quot;中缀表达式转后缀表达式&quot;&gt;&lt;/a&gt;中缀表达式转后缀表达式&lt;/h3&gt;&lt;h4 id=&quot;处理方法&quot;&gt;&lt;a href=&quot;#处理方法&quot; class=&quot;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://www.m26360.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>前中后缀表达式</title>
    <link href="https://www.m26360.com/2021/11/02/%E5%89%8D%E4%B8%AD%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://www.m26360.com/2021/11/02/%E5%89%8D%E4%B8%AD%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2021-11-02T05:22:29.000Z</published>
    <updated>2021-11-02T05:32:43.260Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前中后缀表达式"><a href="#前中后缀表达式" class="headerlink" title="前中后缀表达式"></a>前中后缀表达式</h3><h4 id="前缀表达式"><a href="#前缀表达式" class="headerlink" title="前缀表达式"></a>前缀表达式</h4><p>1)前缀表达式又称波兰式，前缀表达式的运算符位于操作数之前<br>2)例：(3 + 4) * 5 / 6 对应的前缀表达式为： - * + 3 4 5 6<br>3)和之前综合计算器（中缀表达式）相比，只需要一个栈，从右至左扫描前缀表达式，扫描到两个数字入栈，遇到符号就进行运算，然后将结果再次入栈，重复上述操作，直至前缀表达式扫描完成，得到最终结果。</p><h4 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h4><p>1)后缀表达式又称逆波兰表达式，与前缀表达式相似，但运算符位于操作数之后。<br>2)例：(3 + 4) * 5 / 6 对应的后缀表达式为：3 4 + 5 * 6 - </p><h4 id="逆波兰计算器代码实现"><a href="#逆波兰计算器代码实现" class="headerlink" title="逆波兰计算器代码实现"></a>逆波兰计算器代码实现</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.stack;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class PolandNotation &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //后缀表达式（逆波兰表达式为） (3+4)*5-6    =&gt;      3 4 + 5 * 6 -</span><br><span class="line"></span><br><span class="line">        String suffixExpression = <span class="string">&quot;3 4 + 5 * 6 -&quot;</span>;</span><br><span class="line">        int index;</span><br><span class="line">        char ch;</span><br><span class="line">        List&lt;String&gt; rpnList = getListString(suffixExpression);</span><br><span class="line">        int calculator = Calculator(rpnList);</span><br><span class="line">        System.out.println(<span class="string">&quot;计算的结果是：&quot;</span> + calculator);</span><br><span class="line"></span><br><span class="line">        /*思路</span><br><span class="line">        1.先将 3 4 + 5 * 6 - 放到ArrayList中</span><br><span class="line">        2.将ArrayList传递给一个方法，遍历该ArrayList 配合栈完成计算</span><br><span class="line">        */</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将一个逆波兰表达式里的数字和运算符依次添加到ArrayList中</span><br><span class="line">    public static List&lt;String&gt; getListString(String suffixExpression) &#123;</span><br><span class="line">        String[] split = suffixExpression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String ele : split) &#123;</span><br><span class="line">            int i = 0;</span><br><span class="line">            list.add(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int Calculator(List&lt;String&gt; rpnList) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        //创建一个栈，只需要一个栈即可</span><br><span class="line">        Stack&lt;String&gt; numStack = new Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String ele : rpnList) &#123;</span><br><span class="line">            //使用正则表达式判断是否为数字</span><br><span class="line">            <span class="keyword">if</span> (ele.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123;//匹配多位数</span><br><span class="line">                //入栈</span><br><span class="line">                numStack.push(ele);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                int num2 = Integer.parseInt(numStack.pop());</span><br><span class="line">                int num1 = Integer.parseInt(numStack.pop());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ele.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                    res = num2 + num1;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ele.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 - num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ele.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">                    res = num2 * num1;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ele.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 / num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    throw new RuntimeException(<span class="string">&quot;表达式出现错误内容！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                //将结果再次入栈</span><br><span class="line">                numStack.push(String.valueOf(res));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前中后缀表达式&quot;&gt;&lt;a href=&quot;#前中后缀表达式&quot; class=&quot;headerlink&quot; title=&quot;前中后缀表达式&quot;&gt;&lt;/a&gt;前中后缀表达式&lt;/h3&gt;&lt;h4 id=&quot;前缀表达式&quot;&gt;&lt;a href=&quot;#前缀表达式&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://www.m26360.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>利用栈实现综合计算器(2)</title>
    <link href="https://www.m26360.com/2021/11/01/%E5%88%A9%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88%E8%AE%A1%E7%AE%97%E5%99%A8-2/"/>
    <id>https://www.m26360.com/2021/11/01/%E5%88%A9%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88%E8%AE%A1%E7%AE%97%E5%99%A8-2/</id>
    <published>2021-11-01T08:58:30.000Z</published>
    <updated>2021-11-01T09:00:53.190Z</updated>
    
    <content type="html"><![CDATA[<h3 id="综合计算器"><a href="#综合计算器" class="headerlink" title="综合计算器"></a>综合计算器</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1.输入一个字符串类型的表达式，然后计算表达式结果。<br>2.在利用栈实现综合计算器(1)基础上支持了多位数的计算。</p><span id="more"></span><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">package com.stack;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Calculator &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //要计算的表达式</span><br><span class="line">        //String expression = <span class="string">&quot;312+20*6-2&quot;</span>;</span><br><span class="line">        String expression = <span class="string">&quot;1-2-3&quot;</span>;</span><br><span class="line">        //创建数栈和符号栈</span><br><span class="line">        ArrayStack2 numstack = new ArrayStack2(10);</span><br><span class="line">        ArrayStack2 operstack = new ArrayStack2(10);</span><br><span class="line">        //定义所需相关变量</span><br><span class="line">        int index = 0;</span><br><span class="line">        int num1 = 0;</span><br><span class="line">        int num2 = 0;</span><br><span class="line">        int oper = 0;</span><br><span class="line">        int res = 0;//用于接收每一次计算的结果</span><br><span class="line">        char ch = <span class="string">&#x27; &#x27;</span>;//用于接收每一次扫描到的char的结果</span><br><span class="line">        String keepNum = <span class="string">&quot;&quot;</span>;//用于拼接多位数</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            ch = expression.substring(index, index + 1).charAt(0);</span><br><span class="line">            //判断ch是否为数字</span><br><span class="line">            <span class="keyword">if</span> (!operstack.isOper(ch)) &#123;//如果是数字</span><br><span class="line">                //这里需要判断多位数的情况</span><br><span class="line">                //扫描到数字时，需要再向后扫描一位，如果是数，接着再扫描，如果是符号，才将数字入栈</span><br><span class="line">                //定义一个变量字符串，用于拼接数字</span><br><span class="line">                keepNum += ch;</span><br><span class="line">                //如果ch是最后一位，直接入栈</span><br><span class="line">                <span class="keyword">if</span> (index == expression.length() - 1) &#123;</span><br><span class="line">                    numstack.push(Integer.parseInt(keepNum));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    //如果是符号</span><br><span class="line">                    <span class="keyword">if</span> (operstack.isOper(expression.substring(index + 1, index + 2).charAt(0))) &#123;</span><br><span class="line">                        //将字符串转换成数字并入数栈</span><br><span class="line">                        numstack.push(Integer.parseInt(keepNum));</span><br><span class="line">                        //将keepNum重置为空</span><br><span class="line">                        keepNum = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //numstack.push(ch - 48);//减48是因为字符1和数字1相差48</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operstack.isOper(ch)) &#123;//如果是操作符</span><br><span class="line">                //判断符号栈是否为空</span><br><span class="line">                <span class="keyword">if</span> (operstack.isEmpty()) &#123;</span><br><span class="line">                    operstack.push(ch);//如果为空，直接入栈</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;//如果不为空</span><br><span class="line">                    //如果优先级小于等于栈顶符号优先级</span><br><span class="line">                    <span class="keyword">if</span> (operstack.priority(ch) &lt;= operstack.priority(operstack.getTop())) &#123;</span><br><span class="line">                        num1 = numstack.pop();</span><br><span class="line">                        num2 = numstack.pop();</span><br><span class="line">                        oper = operstack.pop();</span><br><span class="line">                        res = numstack.cal(num1, num2, oper);</span><br><span class="line">                        numstack.push(res);</span><br><span class="line">                        operstack.push(ch);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;//如果大于栈顶符号优先级</span><br><span class="line">                        operstack.push(ch);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            //如果表达式扫描完</span><br><span class="line">            <span class="keyword">if</span> (index == expression.length()) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //如果符号栈为空计算结束</span><br><span class="line">            <span class="keyword">if</span> (operstack.isEmpty()) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                num1 = numstack.pop();</span><br><span class="line">                num2 = numstack.pop();</span><br><span class="line">                oper = operstack.pop();</span><br><span class="line">                res = numstack.cal(num1, num2, oper);</span><br><span class="line">                numstack.push(res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;计算结果为：&quot;</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//利用之前写好的数组模拟栈</span><br><span class="line">//需要添加新功能</span><br><span class="line">class ArrayStack2 &#123;</span><br><span class="line">    private int maxSize;//栈的大小</span><br><span class="line">    private int[] stack;//数组存放栈的数据</span><br><span class="line">    private int top = -1;//栈顶，初始化为-1</span><br><span class="line"></span><br><span class="line">    //构造方法</span><br><span class="line">    public ArrayStack2(int maxSize) &#123;</span><br><span class="line">        this.maxSize = maxSize;</span><br><span class="line">        stack = new int[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取栈顶的方法</span><br><span class="line">    public int <span class="function"><span class="title">getTop</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> stack[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回运算符的优先级，优先级用数字表示，数字越大，优先级越高</span><br><span class="line">    public int priority(int oper) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oper == <span class="string">&#x27;*&#x27;</span> || oper == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">return</span> 1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&#x27;+&#x27;</span> || oper == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">return</span> 0;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> -1;//只能运算加减乘除，否则返回-1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断是否为一个操作符</span><br><span class="line">    public boolean isOper(char val) &#123;</span><br><span class="line">        <span class="built_in">return</span> val == <span class="string">&#x27;+&#x27;</span> || val == <span class="string">&#x27;-&#x27;</span> || val == <span class="string">&#x27;*&#x27;</span> || val == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //计算方法</span><br><span class="line">    public int cal(int num1, int num2, int oper) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oper == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">return</span> num2 - num1;//这里需要num2-num1</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">return</span> num1 + num2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">return</span> num1 * num2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> num2 / num1;//这里需要num2/num1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断栈满</span><br><span class="line">    public boolean <span class="function"><span class="title">isFull</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> top == maxSize - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断栈空</span><br><span class="line">    public boolean <span class="function"><span class="title">isEmpty</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> top == -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //入栈</span><br><span class="line">    public void push(int data) &#123;</span><br><span class="line">        //判断栈是否为满</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈已满，无法执行进栈操作！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = data;</span><br><span class="line">        System.out.println(data + <span class="string">&quot;已被添加到栈顶！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //出栈</span><br><span class="line">    public int <span class="function"><span class="title">pop</span></span>() &#123;</span><br><span class="line">        //先判断栈是否为空</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(<span class="string">&quot;栈空，无法执行出栈操作！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        int data = stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        System.out.println(<span class="string">&quot;栈顶数据&quot;</span> + data + <span class="string">&quot;已被删除！&quot;</span>);</span><br><span class="line">        <span class="built_in">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示栈的内容（遍历）</span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈为空！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (int i = top; i &gt;= 0; i--) &#123;</span><br><span class="line">            System.out.println(stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;ArrayStack2&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;stack=&quot;</span> + Arrays.toString(stack) +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;综合计算器&quot;&gt;&lt;a href=&quot;#综合计算器&quot; class=&quot;headerlink&quot; title=&quot;综合计算器&quot;&gt;&lt;/a&gt;综合计算器&lt;/h3&gt;&lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;p&gt;1.输入一个字符串类型的表达式，然后计算表达式结果。&lt;br&gt;2.在利用栈实现综合计算器(1)基础上支持了多位数的计算。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://www.m26360.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>利用栈实现综合计算器(1)</title>
    <link href="https://www.m26360.com/2021/10/31/%E5%88%A9%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88%E8%AE%A1%E7%AE%97%E5%99%A8-1/"/>
    <id>https://www.m26360.com/2021/10/31/%E5%88%A9%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88%E8%AE%A1%E7%AE%97%E5%99%A8-1/</id>
    <published>2021-10-31T04:08:58.000Z</published>
    <updated>2021-10-31T04:22:43.035Z</updated>
    
    <content type="html"><![CDATA[<h3 id="综合计算器"><a href="#综合计算器" class="headerlink" title="综合计算器"></a>综合计算器</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1.输入一个字符串类型的表达式，然后计算表达式结果。</p><span id="more"></span><h4 id="具体思路"><a href="#具体思路" class="headerlink" title="具体思路"></a>具体思路</h4><p>1.需要两个栈，一个存放数字的数栈(numStack)，一个存放运算符（操作符）的符号栈(operStack)<br>1.通过一个index值（索引），来遍历表达式<br>2.如果扫描到发现是一个数字，就直接入数栈<br>3.如果扫描到发现是一个符号，<br>就分为如下情况：<br>3.1如果当前符号栈为空，就直接入符号栈。<br>3.2如果符号栈中有操作符，就进行比较，<font color="#dd0000">如果当前操作符优先级小于或等于栈顶操作符，就从数栈中pop出两个数，并从符号栈中pop出一个符号进行运算(cal)，将得到的结果入数栈，然后将当前的操作符入符号栈。</font><br /><font color="#dd0000">如果当前操作符优先级大于栈顶操作符，就直接入符号栈。</font><br /><br>4.当表达式扫描完，就顺序的从数栈pop两个数，从符号栈中pop一个符号，进行计算，直到数栈中只有一个数，符号栈为空，即为表达式结果。</p><h4 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h4><p>1.只能计算一位数的表达式。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.stack;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Calculator &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //要计算的表达式</span><br><span class="line">        String expression = <span class="string">&quot;3+2*6-2&quot;</span>;</span><br><span class="line">        //创建数栈和符号栈</span><br><span class="line">        ArrayStack2 numstack = new ArrayStack2(10);</span><br><span class="line">        ArrayStack2 operstack = new ArrayStack2(10);</span><br><span class="line">        //定义所需相关变量</span><br><span class="line">        int index = 0;</span><br><span class="line">        int num1 = 0;</span><br><span class="line">        int num2 = 0;</span><br><span class="line">        int oper = 0;</span><br><span class="line">        int res = 0;//用于接收每一次计算的结果</span><br><span class="line">        char ch = <span class="string">&#x27; &#x27;</span>;//用于接收每一次扫描到的char的结果</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            ch = expression.substring(index, index + 1).charAt(0);</span><br><span class="line">            //判断ch是否为数字</span><br><span class="line">            <span class="keyword">if</span> (!operstack.isOper(ch)) &#123;//如果是数字</span><br><span class="line">                numstack.push(ch - 48);//减48是因为字符1和数字1相差48</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operstack.isOper(ch)) &#123;//如果是操作符</span><br><span class="line">                //判断符号栈是否为空</span><br><span class="line">                <span class="keyword">if</span> (operstack.isEmpty()) &#123;</span><br><span class="line">                    operstack.push(ch);//如果为空，直接入栈</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;//如果不为空</span><br><span class="line">                    //如果优先级小于等于栈顶符号优先级</span><br><span class="line">                    <span class="keyword">if</span> (operstack.priority(ch) &lt;= operstack.priority(operstack.getTop())) &#123;</span><br><span class="line">                        num1 = numstack.pop();</span><br><span class="line">                        num2 = numstack.pop();</span><br><span class="line">                        oper = operstack.pop();</span><br><span class="line">                        res = numstack.cal(num1, num2, oper);</span><br><span class="line">                        numstack.push(res);</span><br><span class="line">                        operstack.push(ch);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;//如果大于栈顶符号优先级</span><br><span class="line">                        operstack.push(ch);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            //如果表达式扫描完</span><br><span class="line">            <span class="keyword">if</span> (index == expression.length()) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //如果符号栈为空计算结束</span><br><span class="line">            <span class="keyword">if</span> (operstack.isEmpty()) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                num1 = numstack.pop();</span><br><span class="line">                num2 = numstack.pop();</span><br><span class="line">                oper = operstack.pop();</span><br><span class="line">                res = numstack.cal(num1, num2, oper);</span><br><span class="line">                numstack.push(res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;计算结果为：&quot;</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//利用之前写好的数组模拟栈</span><br><span class="line">//需要添加新功能</span><br><span class="line">class ArrayStack2 &#123;</span><br><span class="line">    private int maxSize;//栈的大小</span><br><span class="line">    private int[] stack;//数组存放栈的数据</span><br><span class="line">    private int top = -1;//栈顶，初始化为-1</span><br><span class="line"></span><br><span class="line">    //构造方法</span><br><span class="line">    public ArrayStack2(int maxSize) &#123;</span><br><span class="line">        this.maxSize = maxSize;</span><br><span class="line">        stack = new int[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取栈顶的方法</span><br><span class="line">    public int <span class="function"><span class="title">getTop</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> stack[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回运算符的优先级，优先级用数字表示，数字越大，优先级越高</span><br><span class="line">    public int priority(int oper) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oper == <span class="string">&#x27;*&#x27;</span> || oper == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">return</span> 1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&#x27;+&#x27;</span> || oper == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">return</span> 0;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> -1;//只能运算加减乘除，否则返回-1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断是否为一个操作符</span><br><span class="line">    public boolean isOper(char val) &#123;</span><br><span class="line">        <span class="built_in">return</span> val == <span class="string">&#x27;+&#x27;</span> || val == <span class="string">&#x27;-&#x27;</span> || val == <span class="string">&#x27;*&#x27;</span> || val == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //计算方法</span><br><span class="line">    public int cal(int num1, int num2, int oper) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oper == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">return</span> num2 - num1;//这里需要num2-num1</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">return</span> num1 + num2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">return</span> num1 * num2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> num2 / num1;//这里需要num2/num1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断栈满</span><br><span class="line">    public boolean <span class="function"><span class="title">isFull</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> top == maxSize - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断栈空</span><br><span class="line">    public boolean <span class="function"><span class="title">isEmpty</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> top == -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //入栈</span><br><span class="line">    public void push(int data) &#123;</span><br><span class="line">        //判断栈是否为满</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈已满，无法执行进栈操作！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = data;</span><br><span class="line">        System.out.println(data + <span class="string">&quot;已被添加到栈顶！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //出栈</span><br><span class="line">    public int <span class="function"><span class="title">pop</span></span>() &#123;</span><br><span class="line">        //先判断栈是否为空</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(<span class="string">&quot;栈空，无法执行出栈操作！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        int data = stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        System.out.println(<span class="string">&quot;栈顶数据&quot;</span> + data + <span class="string">&quot;已被删除！&quot;</span>);</span><br><span class="line">        <span class="built_in">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示栈的内容（遍历）</span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈为空！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (int i = top; i &gt;= 0; i--) &#123;</span><br><span class="line">            System.out.println(stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;ArrayStack2&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;stack=&quot;</span> + Arrays.toString(stack) +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>以上内容为博主总结，用于日后复习与巩固。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;综合计算器&quot;&gt;&lt;a href=&quot;#综合计算器&quot; class=&quot;headerlink&quot; title=&quot;综合计算器&quot;&gt;&lt;/a&gt;综合计算器&lt;/h3&gt;&lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;p&gt;1.输入一个字符串类型的表达式，然后计算表达式结果。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://www.m26360.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构之栈（链式）</title>
    <link href="https://www.m26360.com/2021/10/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88%EF%BC%88%E9%93%BE%E5%BC%8F%EF%BC%89/"/>
    <id>https://www.m26360.com/2021/10/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88%EF%BC%88%E9%93%BE%E5%BC%8F%EF%BC%89/</id>
    <published>2021-10-30T00:57:52.000Z</published>
    <updated>2021-10-30T01:00:55.061Z</updated>
    
    <content type="html"><![CDATA[<h3 id="栈（链式）"><a href="#栈（链式）" class="headerlink" title="栈（链式）"></a>栈（链式）</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1.栈的链式实现<br>2.入栈(push)<br>3.出栈(pop)<br>4.具体请看代码实现</p><span id="more"></span><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.stack;</span><br><span class="line"></span><br><span class="line">public class LinkedStack &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Node node1 = new Node(1);</span><br><span class="line">        Node node2 = new Node(2);</span><br><span class="line">        Node node3 = new Node(3);</span><br><span class="line">        Node node4 = new Node(4);</span><br><span class="line">        Node node5 = new Node(5);</span><br><span class="line">        Node node6 = new Node(5);</span><br><span class="line">        LinkedList linkedList = new LinkedList();</span><br><span class="line">        linkedList.push(node1);</span><br><span class="line">        linkedList.push(node2);</span><br><span class="line">        linkedList.push(node3);</span><br><span class="line">        linkedList.push(node4);</span><br><span class="line">        linkedList.push(node5);</span><br><span class="line">        //测试添加相同data</span><br><span class="line">        linkedList.push(node6);</span><br><span class="line">        linkedList.pop();</span><br><span class="line">        linkedList.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Node &#123;</span><br><span class="line">    private int data;</span><br><span class="line">    private Node next;</span><br><span class="line"></span><br><span class="line">    public Node(int data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int <span class="function"><span class="title">getData</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(int data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node <span class="function"><span class="title">getNext</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNext(Node next) &#123;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class LinkedList &#123;</span><br><span class="line">    Node top = null;</span><br><span class="line"></span><br><span class="line">    //判断是否为空</span><br><span class="line">    public boolean <span class="function"><span class="title">isEmpty</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> top == null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //入栈</span><br><span class="line">    public void push(Node node) &#123;</span><br><span class="line">        node.setNext(top);</span><br><span class="line">        top = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //出栈</span><br><span class="line">    public int <span class="function"><span class="title">pop</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(<span class="string">&quot;栈为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        int data = top.getData();</span><br><span class="line">        System.out.println(<span class="string">&quot;出栈的数据为：&quot;</span> + data);</span><br><span class="line">        top = top.getNext();</span><br><span class="line">        <span class="built_in">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历栈</span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(<span class="string">&quot;栈为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp = top;</span><br><span class="line">        <span class="keyword">while</span> (temp != null) &#123;</span><br><span class="line">            System.out.println(temp.getData());</span><br><span class="line">            temp = temp.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        //剩一个结点单独输出</span><br><span class="line">        //System.out.println(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>以上内容为博主总结，用于日后复习与巩固，如果转载请注明来源，谢谢</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;栈（链式）&quot;&gt;&lt;a href=&quot;#栈（链式）&quot; class=&quot;headerlink&quot; title=&quot;栈（链式）&quot;&gt;&lt;/a&gt;栈（链式）&lt;/h3&gt;&lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;p&gt;1.栈的链式实现&lt;br&gt;2.入栈(push)&lt;br&gt;3.出栈(pop)&lt;br&gt;4.具体请看代码实现&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://www.m26360.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构之栈（数组模拟）</title>
    <link href="https://www.m26360.com/2021/10/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88%EF%BC%88%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%EF%BC%89/"/>
    <id>https://www.m26360.com/2021/10/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88%EF%BC%88%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%EF%BC%89/</id>
    <published>2021-10-30T00:43:25.000Z</published>
    <updated>2021-10-30T00:56:32.621Z</updated>
    
    <content type="html"><![CDATA[<h3 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈(stack)"></a>栈(stack)</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1)栈是一个先入后出的有序列表（FILO-First In Last Out）<br>2)栈是一个限制性表，表中元素的插入和删除只能在线性表的同一端进行，是一种特殊的线性表，允许插入和删除的一端为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)<br>3)根据栈的定义可知，最先放入栈的元素在栈底，最后放入栈的元素在栈顶，而删除元素正好相反，最后放入的元素最先删除，最先放入的元素最后删除。</p><span id="more"></span><h4 id="栈的应用场景"><a href="#栈的应用场景" class="headerlink" title="栈的应用场景"></a>栈的应用场景</h4><p>1.子程序的调用<br>2.处理递归调用<br>3.表达式的转[中缀表达式转后缀表达式]与求值（实际解决）<br>4.二叉树的遍历<br>5.图形的深度优先(depth-first)搜索法</p><h4 id="数组模拟栈"><a href="#数组模拟栈" class="headerlink" title="数组模拟栈"></a>数组模拟栈</h4><p>1.使用数组来模拟栈<br>2.定义一个Top表示栈顶，初始化为-1<br>3.入栈(push)操作：当有数据加入到栈中时<br>top++;<br>stack[top]=data;<br>4.出栈(pop)操作：<br>int fata=stack[top];<br>top–;<br>raturn data;</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.stack;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class ArrayStackDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayStack arrayStack = new ArrayStack(5);</span><br><span class="line">        boolean loop = <span class="literal">true</span>;//控制菜单循环</span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;show：表示显示栈&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;pop：表示出栈&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;push：表示入栈&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;exit：表示退出栈&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入你的选择：&quot;</span>);</span><br><span class="line">            Scanner scanner = new Scanner(System.in);</span><br><span class="line">            String key = scanner.next();</span><br><span class="line">            switch (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;show&quot;</span>:</span><br><span class="line">                    arrayStack.show();</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;pop&quot;</span>:</span><br><span class="line">                    arrayStack.pop();</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;push&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入想添加的数据：&quot;</span>);</span><br><span class="line">                    Scanner sc = new Scanner(System.in);</span><br><span class="line">                    arrayStack.push(sc.nextInt());</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    System.out.println(<span class="string">&quot;程序退出！&quot;</span>);</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//定义一个类，表示栈</span><br><span class="line">class ArrayStack &#123;</span><br><span class="line">    private int maxSize;//栈的大小</span><br><span class="line">    private int[] stack;//数组存放栈的数据</span><br><span class="line">    private int top = -1;//栈顶，初始化为-1</span><br><span class="line"></span><br><span class="line">    //构造方法</span><br><span class="line">    public ArrayStack(int maxSize) &#123;</span><br><span class="line">        this.maxSize = maxSize;</span><br><span class="line">        stack = new int[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断栈满</span><br><span class="line">    public boolean <span class="function"><span class="title">isFull</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> top == maxSize - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断栈空</span><br><span class="line">    public boolean <span class="function"><span class="title">isEmpty</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> top == -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //入栈</span><br><span class="line">    public void push(int data) &#123;</span><br><span class="line">        //判断栈是否为满</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈已满，无法执行进栈操作！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = data;</span><br><span class="line">        System.out.println(data + <span class="string">&quot;已被添加到栈顶！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //出栈</span><br><span class="line">    public int <span class="function"><span class="title">pop</span></span>() &#123;</span><br><span class="line">        //先判断栈是否为空</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(<span class="string">&quot;栈空，无法执行出栈操作！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        int data = stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        System.out.println(<span class="string">&quot;栈顶数据&quot;</span> + data + <span class="string">&quot;已被删除！&quot;</span>);</span><br><span class="line">        <span class="built_in">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示栈的内容（遍历）</span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈为空！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (int i = top; i &gt;= 0; i--) &#123;</span><br><span class="line">            System.out.println(stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;ArrayStack&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;stack=&quot;</span> + Arrays.toString(stack) +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>以上内容为博主总结，用于日后复习与巩固，如果转载请注明来源，谢谢</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;栈-stack&quot;&gt;&lt;a href=&quot;#栈-stack&quot; class=&quot;headerlink&quot; title=&quot;栈(stack)&quot;&gt;&lt;/a&gt;栈(stack)&lt;/h3&gt;&lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;p&gt;1)栈是一个先入后出的有序列表（FILO-First In Last Out）&lt;br&gt;2)栈是一个限制性表，表中元素的插入和删除只能在线性表的同一端进行，是一种特殊的线性表，允许插入和删除的一端为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)&lt;br&gt;3)根据栈的定义可知，最先放入栈的元素在栈底，最后放入栈的元素在栈顶，而删除元素正好相反，最后放入的元素最先删除，最先放入的元素最后删除。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://www.m26360.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法之约瑟夫问题</title>
    <link href="https://www.m26360.com/2021/10/24/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/"/>
    <id>https://www.m26360.com/2021/10/24/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/</id>
    <published>2021-10-24T01:36:14.000Z</published>
    <updated>2021-10-24T02:52:19.928Z</updated>
    
    <content type="html"><![CDATA[<h3 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><h5 id="什么是约瑟夫问题"><a href="#什么是约瑟夫问题" class="headerlink" title="什么是约瑟夫问题"></a>什么是约瑟夫问题</h5><p>设编号为1,2···n的n个人围坐在一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m的那个人出列，他的下一位又从1开始报数，数到m的那个人又出列，以此类推，直到所有人都出列为止，由此产生一个出队编号的数列。</p><span id="more"></span><h4 id="单向环形链表"><a href="#单向环形链表" class="headerlink" title="单向环形链表"></a>单向环形链表</h4><h5 id="构建单向环形链表"><a href="#构建单向环形链表" class="headerlink" title="构建单向环形链表"></a>构建单向环形链表</h5><p>因为解决约瑟夫问题需要用到单向环形链表，所以给出构建环形链表思路。<br>1)创建第一个结点，让first指向该结点，并形成环形。<br>2)后面每创建一个新的结点，就把该结点加入到已有的环形链表中。<br>3)具体参考代码实现</p><h5 id="遍历环形链表"><a href="#遍历环形链表" class="headerlink" title="遍历环形链表"></a>遍历环形链表</h5><p>1)让辅助变量指向first结点。<br>2)while循环遍历，辅助变量.next==first结束。</p><h4 id="解决约瑟夫问题"><a href="#解决约瑟夫问题" class="headerlink" title="解决约瑟夫问题"></a>解决约瑟夫问题</h4><p><font color="#dd0000">（注:因为结点只有一个编号属性，所以代码中建立单向循环链表的方式为for循环）</font><br /><br>1.创建一个辅助变量(helper)，事先应该指向单向环形链表的最后这个结点。(在first变量的前一个)<br>2.先让first和helper移动k-1次。<br>3.当小孩(结点)报数时，再让first和helper变量（指针）同时移动m-1次。<br>4.此时可以将first指向的小孩结点出圈。（输出first）<br>1)first=first.next<br>2)helper.next=first<br>原来first的结点就相当于被删除（出圈）了（没有任何引用被回收）</p><p><img src="https://i.loli.net/2021/10/24/4KZBMQX1CJFE5hd.png" alt="单向环形链表.PNG"></p><p>单向环形链表图</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>包含for循环创建单向循环链表和解决约瑟夫问题。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.linkedlist;</span><br><span class="line"></span><br><span class="line">public class Joseph &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        /*</span><br><span class="line">        关于约瑟夫问题</span><br><span class="line">        此处的n个人即为代码里的nums</span><br><span class="line">        设编号为1,2···n的n个人围坐在一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m的那个人出列</span><br><span class="line">        他的下一位又从1开始报数，数到m的那个人又出列，以此类推，直到所有人都出列为止</span><br><span class="line">        由此产生一个出队编号的数列</span><br><span class="line">        当nums（n）=5，k=1，m=2时，</span><br><span class="line">        出队列的顺序为:</span><br><span class="line">           2,4,1,5,3</span><br><span class="line">        */</span><br><span class="line">        //nums为有几个人</span><br><span class="line">        //k为从第几个开始数</span><br><span class="line">        //m为数几下</span><br><span class="line">        int nums = 5;</span><br><span class="line">        int k = 1;</span><br><span class="line">        int m = 2;</span><br><span class="line">        CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();</span><br><span class="line">        circleSingleLinkedList.newBoy(nums);</span><br><span class="line">        //遍历环形链表</span><br><span class="line">        //circleSingleLinkedList.show();</span><br><span class="line">        //测试Joseph方法解决约瑟夫问题</span><br><span class="line">        circleSingleLinkedList.Joseph(k, m);</span><br><span class="line">        //间隔线</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class CircleSingleLinkedList &#123;</span><br><span class="line">    //创建一个first结点</span><br><span class="line">    private Boy first = null;</span><br><span class="line"></span><br><span class="line">    public void newBoy(int nums) &#123;</span><br><span class="line">        //nums代表要创建几个Boy结点</span><br><span class="line">        //先对nubs做简单的数据校验</span><br><span class="line">        <span class="keyword">if</span> (nums &lt; 1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;nums的值不合法！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Boy curBoy = null;//辅助变量，帮助创建环形链表</span><br><span class="line">        //使用<span class="keyword">for</span>循环创建单向循环链表</span><br><span class="line">        <span class="keyword">for</span> (int i = 1; i &lt;= nums; i++) &#123;</span><br><span class="line">            Boy boy = new Boy(i);</span><br><span class="line">            //如果是第一个小孩，让first指向boy</span><br><span class="line">            <span class="keyword">if</span> (i == 1) &#123;</span><br><span class="line">                first = boy;</span><br><span class="line">                first.setNext(first);//构成环，只有一个boy结点</span><br><span class="line">                curBoy = first;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curBoy.setNext(boy);</span><br><span class="line">                boy.setNext(first);</span><br><span class="line">                curBoy = curBoy.getNext();//也可以写成curBoy = boy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        //判断是否为空</span><br><span class="line">        <span class="keyword">if</span> (first == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Boy temp = first;</span><br><span class="line">        <span class="keyword">while</span> (temp.getNext() != first) &#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp = temp.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        //单独打印以下最后的结点，（因为是先判断temp.getNext() != first，后打印，所以会落下最后一个结点）</span><br><span class="line">        System.out.println(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param k k为从第几个开始数</span><br><span class="line">     * @param m m为数几下</span><br><span class="line">     */</span><br><span class="line">    public void Joseph(int k, int m) &#123;</span><br><span class="line">        Boy helper = first;</span><br><span class="line">        //将helper指向最后结点</span><br><span class="line">        <span class="keyword">while</span> (helper.getNext() != first) &#123;</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        //先将first移动到k的位置，将helper移动到新的末尾结点，也就是first的前一个结点（因为是环形链表）</span><br><span class="line">        <span class="keyword">for</span> (int i = 1; i &lt; k; i++) &#123;</span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        //当链表只剩一个人的时候，循环结束</span><br><span class="line">        <span class="keyword">while</span> (helper != first) &#123;</span><br><span class="line">            //再让first和helper向后移动m-1次</span><br><span class="line">            <span class="keyword">for</span> (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">                first = first.getNext();</span><br><span class="line">                helper = helper.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            //然后让first指向的结点出圈（进行删除操作）</span><br><span class="line">            System.out.println(first);</span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper.setNext(first);</span><br><span class="line">        &#125;</span><br><span class="line">        //当结束<span class="keyword">while</span>循环时，圈中还有一个结点，将它输出</span><br><span class="line">        System.out.println(first);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //创建一个Boy类，表示一个结点</span><br><span class="line">    class Boy &#123;</span><br><span class="line">        private int no;//编号</span><br><span class="line">        private Boy next;//指向下一个结点</span><br><span class="line"></span><br><span class="line">        //带参构造方法</span><br><span class="line">        public Boy(int no) &#123;</span><br><span class="line">            this.no = no;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int <span class="function"><span class="title">getNo</span></span>() &#123;</span><br><span class="line">            <span class="built_in">return</span> no;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setNo(int no) &#123;</span><br><span class="line">            this.no = no;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Boy <span class="function"><span class="title">getNext</span></span>() &#123;</span><br><span class="line">            <span class="built_in">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setNext(Boy next) &#123;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="string">&quot;Boy&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;约瑟夫问题&quot;&gt;&lt;a href=&quot;#约瑟夫问题&quot; class=&quot;headerlink&quot; title=&quot;约瑟夫问题&quot;&gt;&lt;/a&gt;约瑟夫问题&lt;/h3&gt;&lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;h5 id=&quot;什么是约瑟夫问题&quot;&gt;&lt;a href=&quot;#什么是约瑟夫问题&quot; class=&quot;headerlink&quot; title=&quot;什么是约瑟夫问题&quot;&gt;&lt;/a&gt;什么是约瑟夫问题&lt;/h5&gt;&lt;p&gt;设编号为1,2···n的n个人围坐在一圈，约定编号为k（1&amp;lt;=k&amp;lt;=n）的人从1开始报数，数到m的那个人出列，他的下一位又从1开始报数，数到m的那个人又出列，以此类推，直到所有人都出列为止，由此产生一个出队编号的数列。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://www.m26360.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构之双向链表</title>
    <link href="https://www.m26360.com/2021/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.m26360.com/2021/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</id>
    <published>2021-10-16T03:41:38.000Z</published>
    <updated>2021-10-16T04:15:23.502Z</updated>
    
    <content type="html"><![CDATA[<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><h4 id="基本介绍-配合之前文章阅读"><a href="#基本介绍-配合之前文章阅读" class="headerlink" title="基本介绍(配合之前文章阅读)"></a>基本介绍(<font color="#dd0000">配合之前文章阅读</font><br />)</h4><p>1.因为和单向链表大同小异（多了一个pre属性，指向前一个结点），所以将双向链表的遍历，添加，修改，删除写在了同一篇文章。<br>2.遍历show：方法和单链表一样，区别是既可以向前倾，也可以向后查找。<br>3.添加addNode（默认添加到链表最后，无排序）：<br>1)先找到双向链表最后的这个结点<br>2)temp.next=HeroNode；<br>3)HeroNode.pre=temp；<br>4.添加addByOrder：(按照结点编号属性排序)<br>见代码实现</p><span id="more"></span><p>4.修改update：思路和单链表一样<br>5.删除delete：<br>1)因为是双向链表，所以可以实现自我删除某个结点。<br>2)直接找到要删除的结点<br>3)temp.pre.next=temp.next;<br>4)temp.next.pre=temp.pre;</p><h4 id="单向链表缺点"><a href="#单向链表缺点" class="headerlink" title="单向链表缺点"></a>单向链表缺点</h4><p>1.单向链表查找方向只能是一个方向，双向链表可以向前查找也可以向后查找。<br>2.单向链表不能自我删除，需要依靠辅助结点，双向链表可以自我删除，所以单向链表删除结点是，总是要找到temp<font color="#dd0000">(temp是待删结点的前一个结点)</font><br /></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.linkedlist;</span><br><span class="line"></span><br><span class="line">public class DoubleLinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HeroNode2 h1 = new HeroNode2(1, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode2 h2 = new HeroNode2(3, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode2 h3 = new HeroNode2(5, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        HeroNode2 h4 = new HeroNode2(2, <span class="string">&quot;测试&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();</span><br><span class="line">        //doubleLinkedList.addNode(h1);</span><br><span class="line">        //doubleLinkedList.addNode(h2);</span><br><span class="line">        //doubleLinkedList.addNode(h3);</span><br><span class="line">        //doubleLinkedList.addNode(h4);</span><br><span class="line">        doubleLinkedList.addByOrder(h4);</span><br><span class="line">        //doubleLinkedList.addNode(h1);</span><br><span class="line">        doubleLinkedList.addByOrder(h1);</span><br><span class="line">        doubleLinkedList.addByOrder(h2);</span><br><span class="line">        doubleLinkedList.addByOrder(h2);</span><br><span class="line">        doubleLinkedList.addByOrder(h3);</span><br><span class="line"></span><br><span class="line">        //展示链表</span><br><span class="line">        doubleLinkedList.show();</span><br><span class="line">        /*//间隔线</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">        //测试修改结点属性功能</span><br><span class="line">        doubleLinkedList.update(1, <span class="string">&quot;奥特曼&quot;</span>, <span class="string">&quot;打怪兽&quot;</span>);</span><br><span class="line">        doubleLinkedList.show();</span><br><span class="line">        //间隔线</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">        //测试删除结点</span><br><span class="line">        doubleLinkedList.delete(3);</span><br><span class="line">        //测试删除最后结点</span><br><span class="line">        doubleLinkedList.delete(2);</span><br><span class="line">        //测试重复删除同一结点</span><br><span class="line">        doubleLinkedList.delete(3);</span><br><span class="line">        //测试删除不存在结点</span><br><span class="line">        doubleLinkedList.delete(6);</span><br><span class="line">        //展示链表</span><br><span class="line">        doubleLinkedList.show();</span><br><span class="line">        //间隔线</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);*/</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//创建一个双向链表的类</span><br><span class="line">class DoubleLinkedList &#123;</span><br><span class="line">    //初始化一个头结点</span><br><span class="line">    private HeroNode2 head = new HeroNode2(0, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    //返回一个头结点</span><br><span class="line">    public HeroNode2 <span class="function"><span class="title">getHead</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //双向链表添加结点（无序）</span><br><span class="line">    public void addNode(HeroNode2 heroNode2) &#123;</span><br><span class="line">        HeroNode2 temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp.next != null) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heroNode2.no == temp.next.no) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;链表中已经存在编号为：&quot;</span> + heroNode2.no + <span class="string">&quot;的结点了，添加失败！&quot;</span>);</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = heroNode2;</span><br><span class="line">        heroNode2.pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //双向链表添加结点（有序）</span><br><span class="line">    public void addByOrder(HeroNode2 heroNode2) &#123;</span><br><span class="line">        HeroNode2 temp = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //添加结点核心代码</span><br><span class="line">            <span class="keyword">if</span> (heroNode2.no == temp.no) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;链表中已存在编号为：&quot;</span> + heroNode2.no + <span class="string">&quot;的结点了，添加失败！&quot;</span>);</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //判断是否为链表尾部</span><br><span class="line">            <span class="keyword">if</span> (temp.next == null) &#123;</span><br><span class="line">                temp.next = heroNode2;</span><br><span class="line">                heroNode2.pre = temp;</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (heroNode2.no &lt; temp.next.no) &#123;</span><br><span class="line">                heroNode2.next = temp.next;</span><br><span class="line">                temp.next.pre = heroNode2;</span><br><span class="line">                heroNode2.pre = temp;</span><br><span class="line">                temp.next = heroNode2;</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //修改双向链表结点信息</span><br><span class="line">    public void update(int no, String name, String nickname) &#123;</span><br><span class="line">        HeroNode2 temp = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == no) &#123;</span><br><span class="line">                temp.name = name;</span><br><span class="line">                temp.nickname = nickname;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果遍历到最后结点也没找到no结点</span><br><span class="line">            <span class="keyword">if</span> (temp.next == null) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;链表中不存在编号为&quot;</span> + no + <span class="string">&quot;的结点！&quot;</span>);</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //辅助变量后移</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //双向链表删除结点</span><br><span class="line">    //对于双向链表，只需要找到要被删除的结点，无需找到被删结点的前一个结点</span><br><span class="line">    //找到后，自我删除</span><br><span class="line">    public void delete(int no) &#123;</span><br><span class="line">        HeroNode2 temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //判断链表是否为空</span><br><span class="line">            <span class="keyword">if</span> (head.next == null) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //判断编号是否存在</span><br><span class="line">            <span class="keyword">if</span> (temp == null) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;链表中没有&quot;</span> + no + <span class="string">&quot;号结点！&quot;</span>);</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //删除双向链表结点的核心代码</span><br><span class="line">            <span class="keyword">if</span> (temp.no == no) &#123;</span><br><span class="line">                //如果删除的是最后结点，那么不能执行这条语句，不然会报空指针异常</span><br><span class="line">                <span class="keyword">if</span> (temp.next != null) &#123;</span><br><span class="line">                    temp.next.pre = temp.pre;</span><br><span class="line">                &#125;</span><br><span class="line">                temp.pre.next = temp.next;</span><br><span class="line">                System.out.println(<span class="string">&quot;已成功删除编号为：&quot;</span> + no + <span class="string">&quot;的结点！&quot;</span>);</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //继续遍历下一个结点</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示链表(遍历)</span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        //先判断链表是否为空</span><br><span class="line">        <span class="keyword">if</span> (head.next == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //因为头结点不能动，所以需要一个辅助变量来遍历</span><br><span class="line">        HeroNode2 temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //判断是否到链表最后</span><br><span class="line">            <span class="keyword">if</span> (temp == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line"></span><br><span class="line">            //将temp后移，否则死循环</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//英雄类</span><br><span class="line">class HeroNode2 &#123;</span><br><span class="line">    public int no;</span><br><span class="line">    public String name;</span><br><span class="line">    public String nickname;</span><br><span class="line">    public HeroNode2 pre;//前一个结点</span><br><span class="line">    public HeroNode2 next;//后一个结点</span><br><span class="line"></span><br><span class="line">    //构造器</span><br><span class="line">    public HeroNode2(int no, String name, String nickname) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;HeroNode2&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;</span><span class="string">&#x27; +</span></span><br><span class="line"><span class="string">                &quot;, nickname=&#x27;</span><span class="string">&quot; + nickname + &#x27;\&#x27;&#x27; +</span></span><br><span class="line"><span class="string">                &#x27;&#125;&#x27;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>以上内容为博主总结，用于日后复习与巩固，如果转载请注明来源，谢谢。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;双向链表&quot;&gt;&lt;a href=&quot;#双向链表&quot; class=&quot;headerlink&quot; title=&quot;双向链表&quot;&gt;&lt;/a&gt;双向链表&lt;/h3&gt;&lt;h4 id=&quot;基本介绍-配合之前文章阅读&quot;&gt;&lt;a href=&quot;#基本介绍-配合之前文章阅读&quot; class=&quot;headerlink&quot; title=&quot;基本介绍(配合之前文章阅读)&quot;&gt;&lt;/a&gt;基本介绍(&lt;font color=&quot;#dd0000&quot;&gt;配合之前文章阅读&lt;/font&gt;&lt;br /&gt;)&lt;/h4&gt;&lt;p&gt;1.因为和单向链表大同小异（多了一个pre属性，指向前一个结点），所以将双向链表的遍历，添加，修改，删除写在了同一篇文章。&lt;br&gt;2.遍历show：方法和单链表一样，区别是既可以向前倾，也可以向后查找。&lt;br&gt;3.添加addNode（默认添加到链表最后，无排序）：&lt;br&gt;1)先找到双向链表最后的这个结点&lt;br&gt;2)temp.next=HeroNode；&lt;br&gt;3)HeroNode.pre=temp；&lt;br&gt;4.添加addByOrder：(按照结点编号属性排序)&lt;br&gt;见代码实现&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://www.m26360.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构之单向链表-面试题</title>
    <link href="https://www.m26360.com/2021/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://www.m26360.com/2021/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8-%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-10-06T02:39:59.000Z</published>
    <updated>2021-10-14T09:46:14.676Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单向链表（面试题）"><a href="#单向链表（面试题）" class="headerlink" title="单向链表（面试题）"></a>单向链表（面试题）</h3><p><font color="#dd0000">配合之前文章阅读</font><br /></p><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1.求链表有几个有效结点<br>2.求倒数第k个结点<br>3.反转链表</p><span id="more"></span><h5 id="求链表有几个有效结点"><a href="#求链表有几个有效结点" class="headerlink" title="求链表有几个有效结点"></a>求链表有几个有效结点</h5><p>代码实现</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//返回链表中有几个有效结点的方法</span><br><span class="line">    public int getLength(HeroNode head) &#123;</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        int length = 0;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next != null) &#123;</span><br><span class="line">                length++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="求倒数第k个结点"><a href="#求倒数第k个结点" class="headerlink" title="求倒数第k个结点"></a>求倒数第k个结点</h5><p>代码实现</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//查找单链表中的倒数第k个结点</span><br><span class="line">    public HeroNode getKnode(HeroNode head, int k) &#123;</span><br><span class="line">        //计数器</span><br><span class="line">        int counter = 0;</span><br><span class="line">        //判断单链表是否为空</span><br><span class="line">        <span class="keyword">if</span> (head.next == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果不为空，求总结点的个数size</span><br><span class="line">        int size = getLength(head);</span><br><span class="line"></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        //遍历单链表</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &lt;= 0 || k &gt; size) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;输入数值不合法！&quot;</span>);</span><br><span class="line">                <span class="built_in">return</span> null;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (counter == size - k) &#123;</span><br><span class="line">                <span class="built_in">return</span> temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h5><p><img src="https://i.loli.net/2021/10/10/mh3Kd5zBMRHUrc6.png" alt="链表反转1.2步.png"><br><img src="https://i.loli.net/2021/10/10/qvrQCc7AmReVWTZ.png" alt="链表反转3.4步.png"></p><p>代码实现</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//反转链表</span><br><span class="line">    public void reverseLinkList(HeroNode head) &#123;</span><br><span class="line">        //判断单链表是否没有结点或只有一个结点</span><br><span class="line">        <span class="keyword">if</span> (head.next == null || head.next.next == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;单链表没有结点或只有一个结点，无需反转！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        //定义一个辅助变量,帮助我们遍历原来的链表</span><br><span class="line">        HeroNode cur = head.next;</span><br><span class="line">        HeroNode next = null;//指向当前结点（cur）的下一个结点，防止链表断开</span><br><span class="line">        //创建新的头结点</span><br><span class="line">        HeroNode reverseHead = new HeroNode(0, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        //遍历原来的链表，每遍历一个结点，就将其取出，并放在新链表reverseHead的最前端</span><br><span class="line">        <span class="keyword">while</span> (cur != null) &#123;</span><br><span class="line">            next = cur.next;//将next指向cur的下一个结点</span><br><span class="line">            cur.next = reverseHead.next;//将cur插入到reverseHead的前面</span><br><span class="line">            reverseHead.next = cur;//将reseverhead与cur连接</span><br><span class="line">            cur = next;//将cur后移</span><br><span class="line">        &#125;</span><br><span class="line">        //将head指向reseverHead的第一个结点</span><br><span class="line">        head.next = reverseHead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>以上内容为博主总结，用于日后复习与巩固，如果转载请注明来源，谢谢。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;单向链表（面试题）&quot;&gt;&lt;a href=&quot;#单向链表（面试题）&quot; class=&quot;headerlink&quot; title=&quot;单向链表（面试题）&quot;&gt;&lt;/a&gt;单向链表（面试题）&lt;/h3&gt;&lt;p&gt;&lt;font color=&quot;#dd0000&quot;&gt;配合之前文章阅读&lt;/font&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;p&gt;1.求链表有几个有效结点&lt;br&gt;2.求倒数第k个结点&lt;br&gt;3.反转链表&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://www.m26360.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构之单向链表-删除</title>
    <link href="https://www.m26360.com/2021/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8-%E5%88%A0%E9%99%A4/"/>
    <id>https://www.m26360.com/2021/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8-%E5%88%A0%E9%99%A4/</id>
    <published>2021-10-04T10:53:05.000Z</published>
    <updated>2021-10-14T09:46:32.460Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单向链表（删除功能）"><a href="#单向链表（删除功能）" class="headerlink" title="单向链表（删除功能）"></a>单向链表（删除功能）</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1.在单向链表（有排序）基础上，添加了delNode方法，实现了对链表结点（英雄）的删除。</p><span id="more"></span><h4 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h4><p>1.先找到需要删除的结点的前一个结点。<br>2.temp.next=temp.next.next<br>3.被删除的结点，将不会有其他引用指向，会被垃圾回收机制回收。<br>具体请参考代码实现。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.linkedlist;</span><br><span class="line"></span><br><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //进行测试</span><br><span class="line">        //先创建结点</span><br><span class="line">        HeroNode h1 = new HeroNode(1, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode h2 = new HeroNode(3, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode h3 = new HeroNode(5, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        HeroNode h4 = new HeroNode(2, <span class="string">&quot;测试&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        SingleLinkedList singleLinkedList = new SingleLinkedList();</span><br><span class="line"></span><br><span class="line">        //无排序的方法添加</span><br><span class="line">//      singleLinkedList.addNode(h3);</span><br><span class="line">//      singleLinkedList.addNode(h1);</span><br><span class="line">//      singleLinkedList.addNode(h2);</span><br><span class="line"></span><br><span class="line">        //有排序的方法添加</span><br><span class="line">        singleLinkedList.addByOrder(h3);</span><br><span class="line">        singleLinkedList.addByOrder(h1);</span><br><span class="line">        singleLinkedList.addByOrder(h2);</span><br><span class="line"></span><br><span class="line">        //修改结点属性</span><br><span class="line">        singleLinkedList.update(3, <span class="string">&quot;迪迦&quot;</span>, <span class="string">&quot;奥特曼&quot;</span>);</span><br><span class="line">        singleLinkedList.addByOrder(h4);</span><br><span class="line"></span><br><span class="line">        //测试编号重复是否提示添加失败</span><br><span class="line">        //singleLinkedList.addByOrder(h2);</span><br><span class="line">        //singleLinkedList.update(2,<span class="string">&quot;兽&quot;</span>,<span class="string">&quot;shi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        //显示链表</span><br><span class="line">        singleLinkedList.show();</span><br><span class="line">        //间隔线</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">        //删除no为2的结点，再次显示链表</span><br><span class="line">        singleLinkedList.delNode(2);</span><br><span class="line">        singleLinkedList.show();</span><br><span class="line">        //间隔线</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">        //测试删除不存在的结点</span><br><span class="line">        singleLinkedList.delNode(9);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个SingleLinkedList类，管理英雄</span><br><span class="line">class SingleLinkedList &#123;</span><br><span class="line">    //先初始化一个头结点，头结点不要动,不存放具体的数据</span><br><span class="line">    private HeroNode head = new HeroNode(0, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    //添加结点到单向链表</span><br><span class="line">    //思路:当不考虑编号顺序时</span><br><span class="line">    //1.找到当前链表的最后结点</span><br><span class="line">    //2.将最后这个结点的next指向新的结点,然后新结点的next变为null</span><br><span class="line">    public void addNode(HeroNode heroNode) &#123;</span><br><span class="line">        //因为头结点不能动，因此我们需要一个辅助变量temp</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        //遍历链表，找到最后</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //找到链表的最后</span><br><span class="line">            <span class="keyword">if</span> (temp.next == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果没有找到最后，将temp后移</span><br><span class="line">            temp = temp.next;//temp.next为temp的下一个结点</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //当退出<span class="keyword">while</span>循环时，temp就指向了链表的最后</span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第二种添加结点的方法（有排序）,根据排名将英雄插入到指定位置（如果有这个排名，则添加失败并给出提示）</span><br><span class="line">    public void addByOrder(HeroNode heroNode) &#123;</span><br><span class="line">        //因为头结点不能动，所以通过一个辅助变量（指针）来帮助找到添加的位置</span><br><span class="line">        //因为是单链表，因此我们找到的temp是位于添加位置的前一个结点，否则添加不了</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        boolean flag = <span class="literal">false</span>;//用于记录英雄编号是否已经存在，默认不存在</span><br><span class="line"></span><br><span class="line">        //死循环遍历链表</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //判断是否为链表尾部</span><br><span class="line">            <span class="keyword">if</span> (temp.next == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断编号是否存在</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;英雄编号&quot;</span> + heroNode.no + <span class="string">&quot;已经存在，添加失败！&quot;</span>);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断temp.next是否大于heroNode.no，进而确定插入位置</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;    //这里不能写成temp.no &lt; heroNode.no</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //将temp后移，接着循环遍历</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //只有flag为<span class="literal">false</span>的时候才能添加新结点（英雄）</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //修改结点（英雄）的信息，不能改编号no</span><br><span class="line">    public void update(int No, String name, String nickname) &#123;</span><br><span class="line">        //判断是否为空</span><br><span class="line">        <span class="keyword">if</span> (head.next == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //根据传进来的no编号，找到需要修改的辅助结点</span><br><span class="line">        //定义一个辅助变量</span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        boolean flag = <span class="literal">false</span>;//用于记录是否找到该编号的结点，默认为<span class="literal">false</span></span><br><span class="line">        //遍历链表</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //遍历完还没有找到</span><br><span class="line">            <span class="keyword">if</span> (temp == null) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;链表里没有所要修改的编号！&quot;</span>);</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //寻找到了no编号，将标志改为<span class="literal">true</span></span><br><span class="line">            <span class="keyword">if</span> (temp.no == No) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果没找到no，将temp后移</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = name;</span><br><span class="line">            temp.nickName = nickname;</span><br><span class="line">            System.out.println(<span class="string">&quot;已成功修改编号为：&quot;</span> + No + <span class="string">&quot;的结点信息！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除结点</span><br><span class="line">    public void delNode(int No) &#123;</span><br><span class="line">        //定义一个标记，用于判断是否执行删除操作</span><br><span class="line">        boolean flag = <span class="literal">false</span>;</span><br><span class="line">        //定义一个辅助变量</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        //先判断链表是否为空，如果为空</span><br><span class="line">        <span class="keyword">if</span> (head.next == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            //如果不为空</span><br><span class="line">            <span class="keyword">if</span> (No == temp.next.no) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果没找到编号，将temp后移</span><br><span class="line">            temp = temp.next;</span><br><span class="line"></span><br><span class="line">            //如果编号不存在</span><br><span class="line">            <span class="keyword">if</span> (temp.next == null) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;你想删除的结点不存在！&quot;</span>);</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //进行删除操作</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">            System.out.println(<span class="string">&quot;已成功删除编号为：&quot;</span> + No + <span class="string">&quot;的结点！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示链表(遍历)</span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        //先判断链表是否为空</span><br><span class="line">        <span class="keyword">if</span> (head.next == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //因为头结点不能动，所以需要一个辅助变量来遍历</span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //判断是否到链表最后</span><br><span class="line">            <span class="keyword">if</span> (temp == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line"></span><br><span class="line">            //将temp后移，否则死循环</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个HeroNode， 每一个HeroNode对象就是一个结点</span><br><span class="line">class HeroNode &#123;</span><br><span class="line">    public int no;//编号</span><br><span class="line">    public String name;//名称</span><br><span class="line">    public String nickName;//昵称</span><br><span class="line">    public HeroNode next;//指向下一个结点</span><br><span class="line"></span><br><span class="line">    //构造器</span><br><span class="line">    public HeroNode(int no, String name, String nickname) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.nickName = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //为了显示方便，重写toString方法</span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;</span><span class="string">&#x27; +</span></span><br><span class="line"><span class="string">                &quot;, nickName=&#x27;</span><span class="string">&quot; + nickName + &#x27;\&#x27;&#x27; +</span></span><br><span class="line"><span class="string">                &#x27;&#125;&#x27;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>以上内容为博主总结，用于日后复习与巩固，如果转载请注明来源，谢谢。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;单向链表（删除功能）&quot;&gt;&lt;a href=&quot;#单向链表（删除功能）&quot; class=&quot;headerlink&quot; title=&quot;单向链表（删除功能）&quot;&gt;&lt;/a&gt;单向链表（删除功能）&lt;/h3&gt;&lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;p&gt;1.在单向链表（有排序）基础上，添加了delNode方法，实现了对链表结点（英雄）的删除。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://www.m26360.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构之单向链表-修改</title>
    <link href="https://www.m26360.com/2021/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8-%E4%BF%AE%E6%94%B9/"/>
    <id>https://www.m26360.com/2021/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8-%E4%BF%AE%E6%94%B9/</id>
    <published>2021-09-25T06:36:08.000Z</published>
    <updated>2021-10-14T09:46:54.132Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单向链表（修改功能）"><a href="#单向链表（修改功能）" class="headerlink" title="单向链表（修改功能）"></a>单向链表（修改功能）</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1.在单向链表（有排序）基础上，添加了update方法，实现了对链表结点（英雄）属性的修改。</p><span id="more"></span><h4 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h4><p>具体请参考代码实现。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.linkedlist;</span><br><span class="line"></span><br><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //进行测试</span><br><span class="line">        //先创建结点</span><br><span class="line">        HeroNode h1 = new HeroNode(1, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode h2 = new HeroNode(3, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode h3 = new HeroNode(5, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        HeroNode h4 = new HeroNode(2, <span class="string">&quot;测试&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        SingleLinkedList singleLinkedList = new SingleLinkedList();</span><br><span class="line"></span><br><span class="line">        //无排序的方法添加</span><br><span class="line">//      singleLinkedList.addNode(h3);</span><br><span class="line">//      singleLinkedList.addNode(h1);</span><br><span class="line">//      singleLinkedList.addNode(h2);</span><br><span class="line"></span><br><span class="line">        //有排序的方法添加</span><br><span class="line">        singleLinkedList.addByOrder(h3);</span><br><span class="line">        singleLinkedList.addByOrder(h1);</span><br><span class="line">        singleLinkedList.addByOrder(h2);</span><br><span class="line"></span><br><span class="line">        //修改结点属性</span><br><span class="line">        singleLinkedList.update(3, <span class="string">&quot;迪迦&quot;</span>, <span class="string">&quot;奥特曼&quot;</span>);</span><br><span class="line">        singleLinkedList.addByOrder(h4);</span><br><span class="line"></span><br><span class="line">        //测试编号重复是否提示添加失败</span><br><span class="line">        //singleLinkedList.addByOrder(h2);</span><br><span class="line">        //singleLinkedList.update(2,<span class="string">&quot;兽&quot;</span>,<span class="string">&quot;shi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        //显示链表</span><br><span class="line">        singleLinkedList.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个SingleLinkedList类，管理英雄</span><br><span class="line">class SingleLinkedList &#123;</span><br><span class="line">    //先初始化一个头结点，头结点不要动,不存放具体的数据</span><br><span class="line">    private HeroNode head = new HeroNode(0, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    //添加结点到单向链表</span><br><span class="line">    //思路:当不考虑编号顺序时</span><br><span class="line">    //1.找到当前链表的最后结点</span><br><span class="line">    //2.将最后这个结点的next指向新的结点,然后新结点的next变为null</span><br><span class="line">    public void addNode(HeroNode heroNode) &#123;</span><br><span class="line">        //因为头结点不能动，因此我们需要一个辅助变量temp</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        //遍历链表，找到最后</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //找到链表的最后</span><br><span class="line">            <span class="keyword">if</span> (temp.next == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果没有找到最后，将temp后移</span><br><span class="line">            temp = temp.next;//temp.next为temp的下一个结点</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //当退出<span class="keyword">while</span>循环时，temp就指向了链表的最后</span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第二种添加结点的方法（有排序）,根据排名将英雄插入到指定位置（如果有这个排名，则添加失败并给出提示）</span><br><span class="line">    public void addByOrder(HeroNode heroNode) &#123;</span><br><span class="line">        //因为头结点不能动，所以通过一个辅助变量（指针）来帮助找到添加的位置</span><br><span class="line">        //因为是单链表，因此我们找到的temp是位于添加位置的前一个结点，否则添加不了</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        boolean flag = <span class="literal">false</span>;//用于记录英雄编号是否已经存在，默认不存在</span><br><span class="line"></span><br><span class="line">        //死循环遍历链表</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //判断是否为链表尾部</span><br><span class="line">            <span class="keyword">if</span> (temp.next == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断编号是否存在</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;英雄编号&quot;</span> + heroNode.no + <span class="string">&quot;已经存在，添加失败！&quot;</span>);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断temp.next是否大于heroNode.no，进而确定插入位置</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;    //这里不能写成temp.no &lt; heroNode.no</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //将temp后移，接着循环遍历</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //只有flag为<span class="literal">false</span>的时候才能添加新结点（英雄）</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //修改结点（英雄）的信息，不能改编号no</span><br><span class="line">    public void update(int No, String name, String nickname) &#123;</span><br><span class="line">        //判断是否为空</span><br><span class="line">        <span class="keyword">if</span> (head.next == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //根据传进来的no编号，找到需要修改的辅助结点</span><br><span class="line">        //定义一个辅助变量</span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        boolean flag = <span class="literal">false</span>;//用于记录是否找到该编号的结点，默认为<span class="literal">false</span></span><br><span class="line">        //遍历链表</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //遍历完还没有找到</span><br><span class="line">            <span class="keyword">if</span> (temp == null) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;链表里没有所要修改的编号！&quot;</span>);</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //寻找到了no编号，将标志改为<span class="literal">true</span></span><br><span class="line">            <span class="keyword">if</span> (temp.no == No) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果没找到no，将temp后移</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = name;</span><br><span class="line">            temp.nickName = nickname;</span><br><span class="line">            System.out.println(<span class="string">&quot;已成功修改编号为：&quot;</span> + No + <span class="string">&quot;的结点信息！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示链表(遍历)</span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        //先判断链表是否为空</span><br><span class="line">        <span class="keyword">if</span> (head.next == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //因为头结点不能动，所以需要一个辅助变量来遍历</span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //判断是否到链表最后</span><br><span class="line">            <span class="keyword">if</span> (temp == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line"></span><br><span class="line">            //将temp后移，否则死循环</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个HeroNode， 每一个HeroNode对象就是一个结点</span><br><span class="line">class HeroNode &#123;</span><br><span class="line">    public int no;//编号</span><br><span class="line">    public String name;//名称</span><br><span class="line">    public String nickName;//昵称</span><br><span class="line">    public HeroNode next;//指向下一个结点</span><br><span class="line"></span><br><span class="line">    //构造器</span><br><span class="line">    public HeroNode(int no, String name, String nickname) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.nickName = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //为了显示方便，重写toString方法</span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;</span><span class="string">&#x27; +</span></span><br><span class="line"><span class="string">                &quot;, nickName=&#x27;</span><span class="string">&quot; + nickName + &#x27;\&#x27;&#x27; +</span></span><br><span class="line"><span class="string">                &#x27;&#125;&#x27;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>以上内容为博主总结，用于日后复习与巩固，如果转载请注明来源，谢谢。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;单向链表（修改功能）&quot;&gt;&lt;a href=&quot;#单向链表（修改功能）&quot; class=&quot;headerlink&quot; title=&quot;单向链表（修改功能）&quot;&gt;&lt;/a&gt;单向链表（修改功能）&lt;/h3&gt;&lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;p&gt;1.在单向链表（有排序）基础上，添加了update方法，实现了对链表结点（英雄）属性的修改。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://www.m26360.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构之单向链表-有排序</title>
    <link href="https://www.m26360.com/2021/09/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8-%E6%9C%89%E6%8E%92%E5%BA%8F/"/>
    <id>https://www.m26360.com/2021/09/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8-%E6%9C%89%E6%8E%92%E5%BA%8F/</id>
    <published>2021-09-24T08:53:12.000Z</published>
    <updated>2021-10-14T09:47:04.444Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单向链表（有序版）"><a href="#单向链表（有序版）" class="headerlink" title="单向链表（有序版）"></a>单向链表（有序版）</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1.在单向链表（无排序）基础上，添加了addByOrder方法，实现了自动排序以及检测重复编号的功能。</p><span id="more"></span><h4 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h4><p>1.此种方式再添加结点（英雄）时，根据排名将英雄插入到指定位置（按照结点的no，如果有这个排名，则添加失败并给出提示）。<br>2.首先找到新添加结点的位置，通过辅助变量（指针），进而遍历。<br>3.核心实现代码</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">新结点.next = temp.next;</span><br><span class="line">temp.next = 新的结点;</span><br></pre></td></tr></table></figure><p>具体请参考代码实现</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.linkedlist;</span><br><span class="line"></span><br><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //进行测试</span><br><span class="line">        //先创建结点</span><br><span class="line">        HeroNode h1 = new HeroNode(1, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode h2 = new HeroNode(2, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode h3 = new HeroNode(3, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        SingleLinkedList singleLinkedList = new SingleLinkedList();</span><br><span class="line"></span><br><span class="line">        //无排序的方法添加</span><br><span class="line">//      singleLinkedList.addNode(h3);</span><br><span class="line">//      singleLinkedList.addNode(h1);</span><br><span class="line">//      singleLinkedList.addNode(h2);</span><br><span class="line"></span><br><span class="line">        //有排序的方法添加</span><br><span class="line">        singleLinkedList.addByOrder(h3);</span><br><span class="line">        singleLinkedList.addByOrder(h1);</span><br><span class="line">        singleLinkedList.addByOrder(h2);</span><br><span class="line"></span><br><span class="line">        //测试编号重复是否提示添加失败</span><br><span class="line">        singleLinkedList.addByOrder(h2);</span><br><span class="line"></span><br><span class="line">        //显示链表</span><br><span class="line">        singleLinkedList.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个SingleLinkedList类，管理英雄</span><br><span class="line">class SingleLinkedList &#123;</span><br><span class="line">    //先初始化一个头结点，头结点不要动,不存放具体的数据</span><br><span class="line">    private HeroNode head = new HeroNode(0, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    //添加结点到单向链表</span><br><span class="line">    //思路:当不考虑编号顺序时</span><br><span class="line">    //1.找到当前链表的最后结点</span><br><span class="line">    //2.将最后这个结点的next指向新的结点,然后新结点的next变为null</span><br><span class="line">    public void addNode(HeroNode heroNode) &#123;</span><br><span class="line">        //因为头结点不能动，因此我们需要一个辅助变量temp</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        //遍历链表，找到最后</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //找到链表的最后</span><br><span class="line">            <span class="keyword">if</span> (temp.next == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果没有找到最后，将temp后移</span><br><span class="line">            temp = temp.next;//temp.next为temp的下一个结点</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //当退出<span class="keyword">while</span>循环时，temp就指向了链表的最后</span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第二种添加结点的方法（有排序）,根据排名将英雄插入到指定位置（如果有这个排名，则添加失败并给出提示）</span><br><span class="line">    public void addByOrder(HeroNode heroNode) &#123;</span><br><span class="line">        //因为头结点不能动，所以通过一个辅助变量（指针）来帮助找到添加的位置</span><br><span class="line">        //因为是单链表，因此我们找到的temp是位于添加位置的前一个结点，否则添加不了</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        boolean flag = <span class="literal">false</span>;//用于记录英雄编号是否已经存在，默认不存在</span><br><span class="line"></span><br><span class="line">        //死循环遍历链表</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //判断是否为链表尾部</span><br><span class="line">            <span class="keyword">if</span> (temp.next == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断编号是否存在</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;英雄编号&quot;</span> + heroNode.no + <span class="string">&quot;已经存在，添加失败！&quot;</span>);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断temp.next是否大于heroNode.no，进而确定插入位置</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;    //这里不能写成temp.no &lt; heroNode.no</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //将temp后移，接着循环遍历</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //只有flag为<span class="literal">false</span>的时候才能添加新结点（英雄）</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示链表(遍历)</span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        //先判断链表是否为空</span><br><span class="line">        <span class="keyword">if</span> (head.next == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //因为头结点不能动，所以需要一个辅助变量来遍历</span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //判断是否到链表最后</span><br><span class="line">            <span class="keyword">if</span> (temp == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line"></span><br><span class="line">            //将temp后移，否则死循环</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个HeroNode， 每一个HeroNode对象就是一个结点</span><br><span class="line">class HeroNode &#123;</span><br><span class="line">    public int no;//编号</span><br><span class="line">    public String name;//名称</span><br><span class="line">    public String nickName;//昵称</span><br><span class="line">    public HeroNode next;//指向下一个结点</span><br><span class="line"></span><br><span class="line">    //构造器</span><br><span class="line">    public HeroNode(int no, String name, String nickname) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.nickName = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //为了显示方便，重写toString方法</span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;</span><span class="string">&#x27; +</span></span><br><span class="line"><span class="string">                &quot;, nickName=&#x27;</span><span class="string">&quot; + nickName + &#x27;\&#x27;&#x27; +</span></span><br><span class="line"><span class="string">                &#x27;&#125;&#x27;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>以上内容为博主总结，用于日后复习与巩固，如果转载请注明来源，谢谢。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;单向链表（有序版）&quot;&gt;&lt;a href=&quot;#单向链表（有序版）&quot; class=&quot;headerlink&quot; title=&quot;单向链表（有序版）&quot;&gt;&lt;/a&gt;单向链表（有序版）&lt;/h3&gt;&lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;p&gt;1.在单向链表（无排序）基础上，添加了addByOrder方法，实现了自动排序以及检测重复编号的功能。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://www.m26360.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构之单向链表-无排序</title>
    <link href="https://www.m26360.com/2021/09/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8-%E6%97%A0%E6%8E%92%E5%BA%8F/"/>
    <id>https://www.m26360.com/2021/09/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8-%E6%97%A0%E6%8E%92%E5%BA%8F/</id>
    <published>2021-09-22T01:36:18.000Z</published>
    <updated>2021-10-14T09:46:43.876Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单向链表（无排序）"><a href="#单向链表（无排序）" class="headerlink" title="单向链表（无排序）"></a>单向链表（无排序）</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1.链表是有序的列表。<br>2.链表是以结点的方式来存储，是链式存储。<br>3.每个结点包含data域、next域（指向下一结点）。<br>4.链表的各个结点不一定是连续存储。<br>5.链表分为带头结点的链表和没有头结点的链表，根据实际需求来确定。</p><span id="more"></span><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="https://i.loli.net/2021/09/22/sz1aw5hSYVIWlKE.png" alt="链表.PNG"></p><p>以及单链表（带头结点）逻辑结构示意图如下：<br><img src="https://i.loli.net/2021/09/22/ajQwXIh83kTEOgz.png" alt="单链表（带头结点）逻辑结构示意图.png"></p><p>1.添加（创建）<br>1)先创建一个head头结点，作用是表示单链表的头。<br>2)后面每添加一个结点，就直接加入到链表的最后，因为是无排序的版本。<br>2.遍历<br>1)通过一个辅助变量（临时变量），帮助遍历整个链表。（具体代码中有说明和解释）</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.linkedlist;</span><br><span class="line"></span><br><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //进行测试</span><br><span class="line">        //先创建结点</span><br><span class="line">        HeroNode h1 = new HeroNode(1, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode h2 = new HeroNode(2, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode h3 = new HeroNode(3, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        SingleLinkedList singleLinkedList = new SingleLinkedList();</span><br><span class="line">        singleLinkedList.addNode(h1);</span><br><span class="line">        singleLinkedList.addNode(h2);</span><br><span class="line">        singleLinkedList.addNode(h3);</span><br><span class="line">        singleLinkedList.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个SingleLinkedList类，管理英雄</span><br><span class="line">class SingleLinkedList &#123;</span><br><span class="line">    //先初始化一个头结点，头结点不要动,不存放具体的数据</span><br><span class="line">    private HeroNode head = new HeroNode(0, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    //添加结点到单向链表</span><br><span class="line">    //思路:当不考虑编号顺序时</span><br><span class="line">    //1.找到当前链表的最后结点</span><br><span class="line">    //2.将最后这个结点的next指向新的结点,然后新结点的next变为null</span><br><span class="line">    public void addNode(HeroNode heroNode) &#123;</span><br><span class="line">        //因为头结点不能动，因此我们需要一个辅助变量temp</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line"></span><br><span class="line">        //遍历链表，找到最后</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //找到链表的最后</span><br><span class="line">            <span class="keyword">if</span> (temp.next == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果没有找到最后，将temp后移</span><br><span class="line">            temp = temp.next;//temp.next为temp的下一个结点</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //当退出<span class="keyword">while</span>循环时，temp就指向了链表的最后</span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示链表(遍历)</span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">        //先判断链表是否为空</span><br><span class="line">        <span class="keyword">if</span> (head.next == null) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //因为头结点不能动，所以需要一个辅助变量来遍历</span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            //判断是否到链表最后</span><br><span class="line">            <span class="keyword">if</span> (temp == null) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            //将temp后移，否则死循环</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个HeroNode， 每一个HeroNode对象就是一个结点</span><br><span class="line">class HeroNode &#123;</span><br><span class="line">    public int no;//编号</span><br><span class="line">    public String name;//名称</span><br><span class="line">    public String nickName;//昵称</span><br><span class="line">    public HeroNode next;//指向下一个结点</span><br><span class="line"></span><br><span class="line">    //构造器</span><br><span class="line">    public HeroNode(int no, String name, String nickname) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.nickName = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //为了显示方便，重写toString方法</span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;</span><span class="string">&#x27; +</span></span><br><span class="line"><span class="string">                &quot;, nickName=&#x27;</span><span class="string">&quot; + nickName + &#x27;\&#x27;&#x27; +</span></span><br><span class="line"><span class="string">                &#x27;&#125;&#x27;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>以上内容为博主总结，用于日后复习与巩固，如果转载请注明来源，谢谢。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;单向链表（无排序）&quot;&gt;&lt;a href=&quot;#单向链表（无排序）&quot; class=&quot;headerlink&quot; title=&quot;单向链表（无排序）&quot;&gt;&lt;/a&gt;单向链表（无排序）&lt;/h3&gt;&lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;p&gt;1.链表是有序的列表。&lt;br&gt;2.链表是以结点的方式来存储，是链式存储。&lt;br&gt;3.每个结点包含data域、next域（指向下一结点）。&lt;br&gt;4.链表的各个结点不一定是连续存储。&lt;br&gt;5.链表分为带头结点的链表和没有头结点的链表，根据实际需求来确定。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://www.m26360.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>学习目标</title>
    <link href="https://www.m26360.com/2021/09/09/%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87/"/>
    <id>https://www.m26360.com/2021/09/09/%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87/</id>
    <published>2021-09-09T02:58:26.000Z</published>
    <updated>2021-10-06T02:28:39.567Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h3><h4 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h4><p>1.继续学习数据结构与算法<br>2.复习javase<br>3.学习markdown语法<br>4.给博客添加评论功能（未完成）<br>5.百度好像还没收录我的博客，不知道哪里出了问题，有时间再弄一下（未完成）<br>6………</p><h4 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h4><p>1.继续学习数据结构与算法<br>2.复习javase<br>3.百度收录博客<br>4.美化博客（添加音乐分享）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;2021&quot;&gt;&lt;a href=&quot;#2021&quot; class=&quot;headerlink&quot; title=&quot;2021&quot;&gt;&lt;/a&gt;2021&lt;/h3&gt;&lt;h4 id=&quot;9月&quot;&gt;&lt;a href=&quot;#9月&quot; class=&quot;headerlink&quot; title=&quot;9月&quot;&gt;&lt;/a&gt;9月&lt;/h</summary>
      
    
    
    
    <category term="学习进度及目标" scheme="https://www.m26360.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%9B%E5%BA%A6%E5%8F%8A%E7%9B%AE%E6%A0%87/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构之队列(2)环形队列</title>
    <link href="https://www.m26360.com/2021/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97-2-%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97/"/>
    <id>https://www.m26360.com/2021/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97-2-%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97/</id>
    <published>2021-09-09T02:22:52.000Z</published>
    <updated>2021-10-31T04:22:32.617Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数组模拟环形队列"><a href="#数组模拟环形队列" class="headerlink" title="数组模拟环形队列"></a>数组模拟环形队列</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p> 用于解决数组模拟队列不能复用的问题。</p><span id="more"></span><h4 id="思路及图解"><a href="#思路及图解" class="headerlink" title="思路及图解"></a>思路及图解</h4><p>1.front的含义做一个调整：front指向队列的第一个元素。<font color="#dd0000">（原来front指向队列第一个元素的前一个位置）</font><br />也就是说，arr[front]为队列的第一个元素。<font color="#dd0000">（front的初始值为0）</font><br /><br>2.rear的含义也做一个调整：rear指向队列的最后一个元素的后一个位置。<font color="#dd0000">（原来rear指向队列最后一个元素的位置，rear的初始值也为0）</font><br /><br>3.当队列满时，条件为(rear+1)%maxSize==front</p><h4 id="图解（很重要！）"><a href="#图解（很重要！）" class="headerlink" title="图解（很重要！）"></a>图解<font color="#dd0000">（很重要！）</font><br /></h4><p><img src="https://i.loli.net/2021/09/19/FBwzUEtshNaLrDA.png" alt="环形队列.png"></p><p>(1)数组最大容量为：maxSize=4<br>(2)实际容量为：maxSize-1=3<font color="#dd0000">（因为要预留一个空间作为约定，用于判断队列是否为满，因为如果不留空，那么判断队列空和队列满的条件就都为：rear==front，无法判断）</font><br /><br>(3)第一个元素索引为：front=0<font color="#dd0000">（没有做取出操作的时候）</font><br /><br>(4)索引为3的位置空出来了。<br>(5)当索引为0、1、2的位置都存有元素后，认为该队列为满，此时：<br>1)maxSize=4<br>2)front=0<br>3)rear=3<br>即满足(rear+1)%maxSize==0<font color="#dd0000"> rear、front均代表索引。</font><br /></p><p>4.当队列为空时，条件为rear==front<br>5.我们这样分析，队列中有效的数据的个数为：(rear+maxSize-front)%maxSize<br>6.我们就可以在原来的队列上修改得到一个环形队列。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.queue;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class CircleArrayQueueDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建一个环形队列</span><br><span class="line">        CircleArray circleArray = new CircleArray(4);</span><br><span class="line">        //接收用户输入</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        boolean loop = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s(show)：显示队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(exit)：退出队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a(add)：添加数据到队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g(get)：从队列取出数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(head)：查看队列头的数据&quot;</span>);</span><br><span class="line">            char key = sc.next().charAt(0);</span><br><span class="line">            switch (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    circleArray.showQueue();</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                    sc.close();</span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    System.out.println(<span class="string">&quot;程序退出&quot;</span>);</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入一个数：&quot;</span>);</span><br><span class="line">                    Scanner sc1 = new Scanner(System.in);</span><br><span class="line">                    int value1 = sc.nextInt();</span><br><span class="line">                    circleArray.addQueue(value1);</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res = circleArray.getQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;取出的数据是%d\n&quot;</span>, res);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res = circleArray.headQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;队列头数据是%d\n&quot;</span>, res);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CircleArray &#123;</span><br><span class="line">    private int maxSize;    //表示数组最大容量</span><br><span class="line">    private int front;  //队列头 front的含义做一个改变：front指向队列的第一个元素，arr[front]就是队列的第一个元素</span><br><span class="line">    // front的初始值=0</span><br><span class="line">    private int rear;   //队列尾 rear的含义做一个改变：rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为约定</span><br><span class="line">    //rear的初始值=0</span><br><span class="line">    private int[] arr;  //该数组用于存放数据，模拟队列</span><br><span class="line"></span><br><span class="line">    public CircleArray(int arrMaxSize) &#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = new int[maxSize];</span><br><span class="line">        front = 0;</span><br><span class="line">        rear = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断队列是否为满</span><br><span class="line">    public boolean <span class="function"><span class="title">isFull</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> (rear + 1) % maxSize == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断队列是否为空</span><br><span class="line">    public boolean <span class="function"><span class="title">isEmpty</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //添加数据到队列</span><br><span class="line">    public void addQueue(int n) &#123;</span><br><span class="line">        //判断队列是否满</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列满了，无法添加数据！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //添加数据</span><br><span class="line">        arr[rear] = n;</span><br><span class="line">        //将rear后移，这里必须考虑取模%</span><br><span class="line">        rear = (rear + 1) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取队列的数据（出队列）</span><br><span class="line">    public int <span class="function"><span class="title">getQueue</span></span>() &#123;</span><br><span class="line">        //判断队列是否为空</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            //如果为空，通过抛出异常来处理</span><br><span class="line">            throw new RuntimeException(<span class="string">&quot;队列为空，无法获取数据！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        //先用临时变量保存front的值，如果不这么做，会导致<span class="built_in">return</span>之后，无法再修改front的值</span><br><span class="line">        int temp = arr[front];</span><br><span class="line">        front = (front + 1) % (maxSize);</span><br><span class="line">        <span class="built_in">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示队列的所有数据</span><br><span class="line">    public void <span class="function"><span class="title">showQueue</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列为空，没有数据！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        //从front开始遍历，遍历的元素个数为：(rear+maxSize-front)%maxSize</span><br><span class="line">        <span class="keyword">for</span> (int a = front; a &lt; front + size(); a++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;arr[&quot;</span> + a % maxSize + <span class="string">&quot;]=&quot;</span> + arr[a % maxSize] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //System.out.println(<span class="string">&quot;arr[&quot;</span> + a % maxSize + <span class="string">&quot;]=&quot;</span> + arr[a % maxSize] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    //System.out.printf(<span class="string">&quot;arr[%d]=%d\n&quot;</span>, a % maxSize, arr[a % maxSize])</span><br><span class="line"></span><br><span class="line">    //求出当前队列有效数据个数</span><br><span class="line">    public int <span class="function"><span class="title">size</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> (rear + maxSize - front) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示队列的头数据（不是取出数据，仅仅是显示）</span><br><span class="line">    public int <span class="function"><span class="title">headQueue</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(<span class="string">&quot;队列为空，没有头数据！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><font color="#dd0000"></font><br /></p><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>以上内容为博主总结，用于日后复习与巩固。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;数组模拟环形队列&quot;&gt;&lt;a href=&quot;#数组模拟环形队列&quot; class=&quot;headerlink&quot; title=&quot;数组模拟环形队列&quot;&gt;&lt;/a&gt;数组模拟环形队列&lt;/h3&gt;&lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;p&gt; 用于解决数组模拟队列不能复用的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://www.m26360.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构之队列(1)</title>
    <link href="https://www.m26360.com/2021/09/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97(1)/"/>
    <id>https://www.m26360.com/2021/09/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97(1)/</id>
    <published>2021-09-01T02:04:40.000Z</published>
    <updated>2021-10-14T09:47:17.363Z</updated>
    
    <content type="html"><![CDATA[<h3 id="队列（数组模拟实现）"><a href="#队列（数组模拟实现）" class="headerlink" title="队列（数组模拟实现）"></a>队列（数组模拟实现）</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1.队列是个有序列表，可以用数组或链表来实现<br>2.遵循先入先出原则，即先存入队列的数据先取出，后存入队列的数据后取出</p><span id="more"></span><h4 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h4><p>1.队列的输出、输入分别从前后端来处理，需要两个变量front和rear分别记录队列前后端的索引，front会随着数据的输出而改变，rear会随着数据的输入而改变。还需要一个变量maxSize来记录队列的最大容量。<br><font color="#dd0000"><br>front = -1，进行初始化，指向队列头的前一个位置<br>rear = -1， 指向队列尾部的数据（就是队列最后一个数据）<br></font><br /></p><h4 id="队列数据的添加操作"><a href="#队列数据的添加操作" class="headerlink" title="队列数据的添加操作"></a>队列数据的添加操作</h4><p>1.将数据存入队列时称为“addQueue”，“addQueue”的处理需要两个步骤：<br>1)先判断队列是否为满，若尾指针rear小于队列的最大索引maxsize-1，则将数据存入rear所指的数组元素中，否则无法存入数据。<font color="#dd0000">（rear==maxSize-1时，队列满，即无法添加数据）</font><br /><br>2)将尾指针(rear)往后移：rear+1，将要添加的数赋值给索引为rear+1的数组。<font color="#dd0000">（注：当front==rear时，队列为空）</font><br /></p><h4 id="队列数据的取出操作"><a href="#队列数据的取出操作" class="headerlink" title="队列数据的取出操作"></a>队列数据的取出操作</h4><p>1.从队列中取出数据时称为“getQueue”，“getQueue”的处理需要两个步骤：<br>1)判断队列是否为空。<br>2)将front往后移，取出的数为索引为rear+1的元素。</p><h4 id="已知问题及优化"><a href="#已知问题及优化" class="headerlink" title="已知问题及优化"></a>已知问题及优化</h4><p>1.问题：数组使用一次就不能用了，没有达到复用的效果。<br>2.优化：将这个数组使用算法，改进成一个环形的队列。（取模:%）<font color="#dd0000">（见数据结构之队列(2)）</font><br /></p><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.queue;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class ArrayQueueDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建队列</span><br><span class="line">        ArrayQueue arrayQueue = new ArrayQueue(3);</span><br><span class="line">        //接收用户输入</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        boolean loop = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s(show)：显示队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(exit)：退出队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a(add)：添加数据到队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g(get)：从队列取出数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(head)：查看队列头的数据&quot;</span>);</span><br><span class="line">            char key = sc.next().charAt(0);</span><br><span class="line">            switch (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    arrayQueue.showQueue();</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                    sc.close();</span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    System.out.println(<span class="string">&quot;程序退出&quot;</span>);</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入一个数：&quot;</span>);</span><br><span class="line">                    Scanner sc1 = new Scanner(System.in);</span><br><span class="line">                    int value1 = sc.nextInt();</span><br><span class="line">                    arrayQueue.addQueue(value1);</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res = arrayQueue.getQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;取出的数据是%d\n&quot;</span>, res);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res = arrayQueue.headQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;队列头数据是%d\n&quot;</span>, res);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//编写一个ArrayQueue的类</span><br><span class="line">class ArrayQueue &#123;</span><br><span class="line">    private int maxSize;    //表示数组最大容量</span><br><span class="line">    private int front;  //队列头</span><br><span class="line">    private int rear;   //队列尾</span><br><span class="line">    private int[] arr;  //该数组用于存放数据，模拟队列</span><br><span class="line"></span><br><span class="line">    //创建队列的构造器</span><br><span class="line">    public ArrayQueue(int arrMaxSize) &#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = new int[maxSize];</span><br><span class="line">        front = -1;   //进行初始化，指向队列头的前一个位置</span><br><span class="line">        rear = -1;    //指向队列尾部的数据（就是队列最后一个数据）</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断队列是否满</span><br><span class="line">    public boolean <span class="function"><span class="title">isFull</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> maxSize - 1 == rear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断队列是否为空</span><br><span class="line">    public boolean <span class="function"><span class="title">isEmpty</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> front == rear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //添加数据到队列</span><br><span class="line">    public void addQueue(int n) &#123;</span><br><span class="line">        //判断队列是否满</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列满了，无法添加数据！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        //添加数据</span><br><span class="line">        rear++;</span><br><span class="line">        arr[rear] = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取队列的数据（出队列）</span><br><span class="line">    public int <span class="function"><span class="title">getQueue</span></span>() &#123;</span><br><span class="line">        //判断队列是否为空</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            //如果为空，通过抛出异常来处理</span><br><span class="line">            throw new RuntimeException(<span class="string">&quot;队列为空，无法获取数据！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        front++;</span><br><span class="line">        <span class="built_in">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示队列的所有数据</span><br><span class="line">    public void <span class="function"><span class="title">showQueue</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列为空，没有数据！&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (int a = 0; a &lt; arr.length; a++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;arr[&quot;</span> + a + <span class="string">&quot;]=&quot;</span> + arr[a] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //显示队列的头数据（不是取出数据，仅仅是显示）</span><br><span class="line">    public int <span class="function"><span class="title">headQueue</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(<span class="string">&quot;队列为空，没有头数据！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> arr[front + 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>以上内容为博主总结，用于日后复习与巩固，如果转载请注明来源，谢谢。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;队列（数组模拟实现）&quot;&gt;&lt;a href=&quot;#队列（数组模拟实现）&quot; class=&quot;headerlink&quot; title=&quot;队列（数组模拟实现）&quot;&gt;&lt;/a&gt;队列（数组模拟实现）&lt;/h3&gt;&lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;p&gt;1.队列是个有序列表，可以用数组或链表来实现&lt;br&gt;2.遵循先入先出原则，即先存入队列的数据先取出，后存入队列的数据后取出&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://www.m26360.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>学习进度</title>
    <link href="https://www.m26360.com/2021/08/22/%E5%AD%A6%E4%B9%A0%E8%BF%9B%E5%BA%A6/"/>
    <id>https://www.m26360.com/2021/08/22/%E5%AD%A6%E4%B9%A0%E8%BF%9B%E5%BA%A6/</id>
    <published>2021-08-22T13:22:49.000Z</published>
    <updated>2021-10-16T04:16:13.606Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h3><h4 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h4><p>1.将hexo博客进行了双线部署。<br>2.将博客提交到百度收录。</p><h4 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h4><p>1.学习队列<br>2.学习环形队列</p><h4 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h4><p>1.学习单链表（无序）<br>2.学习单链表（有序）<br>3.学习双向链表(无序，有序)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;2021&quot;&gt;&lt;a href=&quot;#2021&quot; class=&quot;headerlink&quot; title=&quot;2021&quot;&gt;&lt;/a&gt;2021&lt;/h3&gt;&lt;h4 id=&quot;8月&quot;&gt;&lt;a href=&quot;#8月&quot; class=&quot;headerlink&quot; title=&quot;8月&quot;&gt;&lt;/a&gt;8月&lt;/h</summary>
      
    
    
    
    <category term="学习进度及目标" scheme="https://www.m26360.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%9B%E5%BA%A6%E5%8F%8A%E7%9B%AE%E6%A0%87/"/>
    
    
  </entry>
  
  <entry>
    <title>关于昨天尝试双线部署hexo</title>
    <link href="https://www.m26360.com/2021/08/17/%E5%85%B3%E4%BA%8E%E6%98%A8%E5%A4%A9%E5%B0%9D%E8%AF%95%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2hexo/"/>
    <id>https://www.m26360.com/2021/08/17/%E5%85%B3%E4%BA%8E%E6%98%A8%E5%A4%A9%E5%B0%9D%E8%AF%95%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2hexo/</id>
    <published>2021-08-17T01:00:51.000Z</published>
    <updated>2021-08-17T09:43:15.724Z</updated>
    
    <content type="html"><![CDATA[<p>因为此博客是部署在Github上的，所以国内访问会比较慢，甚至无法访问，正好看到了将hexo双线部署在Github和Coding上，顺便也能让百度收录此博客，于是就尝试了一下，coding账号注册，新建项目，新建仓库，修改博客config文件，修改DNS解析，配置密匙，将Github解析改为境外访问等等…一气呵成，最后发现博客无法打开，因为网上的教程都是腾讯云开发平台的教程，好像是coding被腾讯收购了，而我用的又是coding，难免会有些设置不存在或者找不到，导致最终失败了，昨天也是弄了几个小时，头晕眼花，等过一段时间我再重新试一下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为此博客是部署在Github上的，所以国内访问会比较慢，甚至无法访问，正好看到了将hexo双线部署在Github和Coding上，顺便也能让百度收录此博客，于是就尝试了一下，coding账号注册，新建项目，新建仓库，修改博客config文件，修改DNS解析，配置密匙，将G</summary>
      
    
    
    
    <category term="记录心情" scheme="https://www.m26360.com/categories/%E8%AE%B0%E5%BD%95%E5%BF%83%E6%83%85/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo 双线部署到Coding和GitHub</title>
    <link href="https://www.m26360.com/2021/08/16/hexo-%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2%E5%88%B0Coding%E5%92%8CGitHub/"/>
    <id>https://www.m26360.com/2021/08/16/hexo-%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2%E5%88%B0Coding%E5%92%8CGitHub/</id>
    <published>2021-08-16T08:50:56.000Z</published>
    <updated>2021-08-22T13:22:11.646Z</updated>
    
    <content type="html"><![CDATA[<p>因为教程步骤繁琐，具体请参考:<a href="https://cloud.tencent.com/developer/article/1834005">https://cloud.tencent.com/developer/article/1834005</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为教程步骤繁琐，具体请参考:&lt;a href=&quot;https://cloud.tencent.com/developer/article/1834005&quot;&gt;https://cloud.tencent.com/developer/article/1834005&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>解决hexo部署之后需要重新修改域名的问题</title>
    <link href="https://www.m26360.com/2021/08/16/%E8%A7%A3%E5%86%B3hexo%E9%83%A8%E7%BD%B2%E4%B9%8B%E5%90%8E%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E4%BF%AE%E6%94%B9%E5%9F%9F%E5%90%8D%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://www.m26360.com/2021/08/16/%E8%A7%A3%E5%86%B3hexo%E9%83%A8%E7%BD%B2%E4%B9%8B%E5%90%8E%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E4%BF%AE%E6%94%B9%E5%9F%9F%E5%90%8D%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2021-08-16T06:14:29.000Z</published>
    <updated>2021-08-16T06:21:56.695Z</updated>
    
    <content type="html"><![CDATA[<h3 id="教程开始"><a href="#教程开始" class="headerlink" title="教程开始"></a>教程开始</h3><p>1.打开博客的source目录，创建CNAME文件，在CNAME中写上自己的域名。<br>2.在hexo博客目录下，右键选择Git Bash Here,输入以下代码并回车：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>3.over!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;教程开始&quot;&gt;&lt;a href=&quot;#教程开始&quot; class=&quot;headerlink&quot; title=&quot;教程开始&quot;&gt;&lt;/a&gt;教程开始&lt;/h3&gt;&lt;p&gt;1.打开博客的source目录，创建CNAME文件，在CNAME中写上自己的域名。&lt;br&gt;2.在hexo博客目录下，右键选择</summary>
      
    
    
    
    <category term="hexo博客操作相关" scheme="https://www.m26360.com/categories/hexo%E5%8D%9A%E5%AE%A2%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
</feed>
